#@ !  This file was generated by kMOS (kMC modelling on steroids)
#@ !  written by Max J. Hoffmann mjhoffmann@gmail.com (C) 2009-2013.
#@ !  The model was written by Andreas Garhammer.
#@ 
#@ !  This file is part of kmos.
#@ !
#@ !  kmos is free software; you can redistribute it and/or modify
#@ !  it under the terms of the GNU General Public License as published by
#@ !  the Free Software Foundation; either version 2 of the License, or
#@ !  (at your option) any later version.
#@ !
#@ !  kmos is distributed in the hope that it will be useful,
#@ !  but WITHOUT ANY WARRANTY; without even the implied warranty of
#@ !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#@ !  GNU General Public License for more details.
#@ !
#@ !  You should have received a copy of the GNU General Public License
#@ !  along with kmos; if not, write to the Free Software
#@ !  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
#@ !  USA
#@ !****h* kmos/base_acf
#@ ! FUNCTION
#@ !    Implements the mappings between the real space lattice
#@ !    and the 1-D lattice, which kmos/base operates on.
#@ !    Furthermore replicates all geometry specific functions of kmos/base
#@ !    in terms of lattice coordinates.
#@ !    Using this module each site can be addressed with 4-tuple
#@ !    ``(i, j, k, n)`` where ``i, j, k`` define the unit cell and
#@ !    ``n`` the site within the unit cell.
#@ !
#@ !******
#@ 
#@ 
#@ module base_acf
#@ use kind_values
#@ use base
#@ 
#@ 
#@ 
#@ !------ No implicit definition of variables !
#@ implicit none
#@  
#@ 
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:), allocatable :: id_arr
#@ !****v* base_acf/id_arr
#@ ! FUNCTION
#@ !   Stores id of the particle, which occupies the nr_of_sites.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind=iint), dimension(:), allocatable :: site_arr
#@ !****v* base_acf/site_arr
#@ ! FUNCTION
#@ !   Stores site number, for every particle_id.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble), dimension(:,:), allocatable :: displacement
#@ !****v* base_acf/displacement
#@ ! FUNCTION
#@ !   Stores the displacement for each particle.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:), allocatable :: property_acf
#@ !****v* base_acf/property_acf
#@ ! FUNCTION
#@ !   Stores type_index for the corresponding property of each site.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:), allocatable :: property_o
#@ !****v* base_acf/property_o
#@ ! FUNCTION
#@ !   Stores for each particle the initial property between two decorrelation times.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble), dimension(:), allocatable :: types
#@ !****v* base_acf/types
#@ ! FUNCTION
#@ !   Stores all possible properties.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble), dimension(:, :), allocatable :: product_property
#@ !****v* base_acf/product_property
#@ ! FUNCTION
#@ !   Stores all possible combinations between two properties.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint), dimension(:, :), allocatable :: trajectory
#@ !****v* base_acf/trajectory
#@ ! FUNCTION
#@ !   Stores the trajectory (property for every kmc step) for each particle.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind = rdouble), dimension(:), allocatable :: buffer_acf
#@ !****v* base_acf/buffer_acf
#@ ! FUNCTION
#@ !   Stores the product between the initial property_o and the current property of each particle.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind = rdouble), dimension(:), allocatable :: config_bin
#@ !****v* base_acf/config_bin
#@ ! FUNCTION
#@ !   Stores the property average over all particles and all wraps for every bin.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint), dimension(:), allocatable :: counter_write_in_bin
#@ !****v* base_acf/counter_write_in_bin
#@ ! FUNCTION
#@ !   Stores number of contributions to a bin.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: nr_of_types
#@ !****v* base_acf/nr_of_types
#@ ! FUNCTION
#@ !   Stores number of different types of porperties.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind = iint) :: nr_of_ions
#@ !****v* base_acf/nr_of_ions
#@ ! FUNCTION
#@ !   Stores the number of ions in the lattice.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: nr_of_ions_before_kmc_step_acf
#@ !****v* base_acf/nr_of_ions_before_kmc_step_acf
#@ ! FUNCTION
#@ !   Stores the number of ions which contributes to the ACF.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: bin_index
#@ !****v* base_acf/bin_index
#@ ! FUNCTION
#@ !   Index of bin which is needed for the calculation of the ACF.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: extended_nr_of_bins
#@ !****v* base_acf/extended_nr_of_bins
#@ ! FUNCTION
#@ !   Number of bins after the multiplication with safety factor.
#@ !******
#@ !------ A. Garhammer 2016------
#@ integer(kind = iint) :: nr_of_bins
#@ !****v* base_acf/nr_of_bins
#@ ! FUNCTION
#@ !   Number of bins for the calculation of the ACF.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: t_bin
#@ !****v* base_acf/t_bin
#@ ! FUNCTION
#@ !   Bin size in s.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: t_f
#@ !****v* base_acf/t_f
#@ ! FUNCTION
#@ !   Decorrelation time of the ACF in s, which is given by the user.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: t_o
#@ !****v* base_acf/t_o
#@ ! FUNCTION
#@ !  Stores the starting time after the decorrelation of one cycle was reached.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: wrap_count
#@ !****v* base_acf/wrap_count
#@ ! FUNCTION
#@ !  Number of wraps for the time average of every bin.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=ilong) :: kmc_step_acf
#@ !****v* base_acf/kmc_step_acf
#@ ! FUNCTION
#@ !   Number of kMC steps executed for the calculation of acf.
#@ !******
#@ !------ A. Garhammer 2015------
#@ integer(kind=iint) :: nr_of_steps
#@ !****v* base_acf/nr_of_steps
#@ ! FUNCTION
#@ !   Number of kMC steps for which the trajectory is recorded.
#@ !******
#@ !------ A. Garhammer 2016------
#@ real(kind=rdouble) :: nr_of_annhilations
#@ !****v* base_acf/nr_of_annhilations
#@ ! FUNCTION
#@ !   Number of annhilations.
#@ !******
#@
#@ 
#@ !****************
#@ contains
#@ !****************
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine calc_nr_of_ions(trace_species)
#@ !****f* base_acf/calc_nr_of_ions
#@ ! FUNCTION
#@ !    Calculates the number of ions.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``trace_species`` positive integer number that represents the species which is traced.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k, species, volume
#@ integer(kind = iint), intent(in) :: trace_species
#@ 
#@ nr_of_ions = 0
#@ 
#@ call get_volume(volume)
#@ 
#@ do k = 1, volume
#@   species = get_species(k)
#@ if( species == trace_species )then
#@ nr_of_ions = nr_of_ions + 1
#@ endif
#@ enddo
#@ 
#@ 
#@ end subroutine calc_nr_of_ions
#@ 
#@ subroutine update_nr_of_ions_before_kmc_step_acf()
#@ !****f* base_acf/update_nr_of_ions_before_kmc_step_acf
#@ ! FUNCTION
#@ !    
#@ !
#@ ! ARGUMENTS
#@ !    * ``none``
#@ !
#@ !   
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ nr_of_ions_before_kmc_step_acf = nr_of_ions
#@ 
#@ 
#@ end subroutine update_nr_of_ions_before_kmc_step_acf
#@ 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_nr_of_ions(return_nr_of_ions)
#@ !****f* base_acf/get_nr_of_ions
#@ ! FUNCTION
#@ !    Returns current number of ions of the trace_species as iint integer as defined in kind_values.f90.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_nr_of_ions`` writeable integer, where the nr_of_ions will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(out) :: return_nr_of_ions
#@ 
#@ 
#@ return_nr_of_ions = nr_of_ions
#@ 
#@ end subroutine get_nr_of_ions
#@ 
#@ 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine initialize_acf(trace_species)
#@ !****f* base_acf/initialize_acf
#@ ! FUNCTION
#@ !    initialize_acf allocates and initializes the arrays for calculating the autocorrelation function (ACF).
#@ !    The subroutine assigns each particle (trace_species) an id for the initial state and saves this id in id_arr.
#@ !    The user have to call this subroutine, before the kmc run can start to calculate the ACF
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``trace_species`` positive integer number that represents the species which is traced.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k, i, volume, species
#@ integer(kind = iint), intent(in) :: trace_species
#@ 
#@ !Calculation of the number of ions
#@ call calc_nr_of_ions(trace_species)
#@ nr_of_ions_before_kmc_step_acf = nr_of_ions
#@ 
#@ !allocates the arrays for the autocorrelationfunction and initialize with 0
#@ call get_volume(volume)
#@ 
#@ 
#@ !Start initialization process for id_arr and trajectory
#@ i = 1
#@ do k = 1, volume
#@   species = get_species(k)
#@ if( species == trace_species )then
#@ id_arr(k) = i
#@ site_arr(i) = k
#@ i = i + 1
#@ else
#@ id_arr(k) = 0
#@ endif
#@ enddo
#@ 
#@ call update_property_and_buffer_acf()
#@ 
#@ 
#@ end subroutine initialize_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine initialize_mean_squared_displacement(trace_species)
#@ !****f* base_acf/initialize_mean_squared_displacement
#@ ! FUNCTION
#@ !    initialize_mean_squared_displacement allocates and initializes the arrays for calculating the mean squared displacement.
#@ !    The subroutine assigns each particle (trace_species) an id for the initial state and saves this id in id_arr.
#@ !    The user must specify the species to be used for calculating the mean squared displacement.
#@ !    The user have to call this subroutine, before the kmc run can start to calculate the mean squared displacement.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``trace_species`` positive integer number that represents the species which is traced.
#@ !
#@ !
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k, i, volume, species
#@ integer(kind = iint), intent(in) :: trace_species
#@ !Calculation of the number of ions
#@ call calc_nr_of_ions(trace_species)
#@ call get_volume(volume)
#@ 
#@ 
#@ 
#@ allocate(id_arr(0:volume))
#@ id_arr = 0
#@ 
#@ allocate(site_arr(0:volume))
#@ site_arr = 0
#@ 
#@ 
#@ 
#@ allocate(displacement(0:nr_of_ions, 3))
#@ displacement = 0
#@ 
#@ 
#@ 
#@ !Start initialization process for id_arr
#@ i = 1
#@ do k = 1, volume
#@    species = get_species(k)
#@ if( species == trace_species )then
#@ id_arr(k) = i
#@ site_arr(i) = k
#@ i = i + 1
#@ else
#@ id_arr(k) = 0
#@ endif
#@ enddo
#@ 
#@ 
#@ end subroutine initialize_mean_squared_displacement
#@ 
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_displacement(particle_id,return_displacement)
#@ !****f* base_acf/get_displacement
#@ ! FUNCTION
#@ !    Returns displacement for a particle.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_displacement`` writeable 3 dimensonal array, where the displacement of a particle will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind=iint), intent(in) :: particle_id
#@ real(kind=rdouble), dimension(3),  intent(out) :: return_displacement
#@ 
#@ return_displacement = displacement(particle_id,:)
#@ 
#@ end subroutine get_displacement
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine allocate_tracing_arr(nr_of_types_arg)
#@ !****f* base_acf/allocate_acf
#@ ! FUNCTION
#@ !    Allocates the complete arrays for the calculation of the ACF.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``nr_of_types_arg`` positive integer that represents the number of different types of properties
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind = iint), intent(in) :: nr_of_types_arg
#@ integer(kind = iint) :: volume
#@ 
#@ call get_volume(volume)
#@ nr_of_types = nr_of_types_arg
#@ 
#@ allocate(types(nr_of_types))
#@ types = 0
#@ 
#@ allocate(property_acf(0:volume))
#@ property_acf = 0
#@ 
#@ allocate(property_o(0:volume))
#@ property_o = 0
#@ 
#@ allocate(product_property(0:nr_of_types,0:nr_of_types))
#@ product_property = 0
#@ 
#@ allocate(id_arr(0:volume))
#@ id_arr = 0
#@ 
#@ allocate(site_arr(0:volume))
#@ site_arr = 0
#@ 
#@ allocate(buffer_acf(0:volume))
#@ buffer_acf = 0
#@ 
#@ 
#@ 
#@ end subroutine allocate_tracing_arr
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine allocate_trajectory(nr_of_steps_arg)
#@ !****f* base_acf/allocate_trajectory
#@ ! FUNCTION
#@ !    Allocates and intializes the trajecotry array.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``None``.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint), intent(in) :: nr_of_steps_arg
#@ integer(kind = iint) :: i
#@ 
#@ nr_of_steps = nr_of_steps_arg 
#@ 
#@ allocate(trajectory(0:nr_of_ions, nr_of_steps + 1))
#@ trajectory = 0
#@ 
#@ do i = 1 , nr_of_ions
#@ trajectory(i,1) = site_arr(i)
#@ enddo
#@ 
#@ end subroutine allocate_trajectory
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine allocate_config_bin_acf(t_bin_arg,t_f_arg,safety_factor_t_f_arg,extending_factor_arg)
#@ !****f* base_acf/allocate_config_bin_acf
#@ ! FUNCTION
#@ !    allocate_config_bin_acf allocates and initializes the arrays and the variables for the on the fly calculation of the autocorrelation function (ACF).
#@ !    The user must specify the number of bins and the decay time to be used for calculating the ACF.
#@ !    From this, the bin size t_bin is calculated.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``nr_of_bins_in`` writeable integer, where the number of bins for the calculation of the ACF will be stored.
#@ !    * ``t_f_in`` writeable real, where the decay time t_f of the ACF will be stored
#@ !******
#@ !---------------I/O variables---------------
#@ real(kind = rdouble), intent(in) :: t_bin_arg
#@ real(kind = rdouble), intent(in) :: t_f_arg
#@ integer(kind = iint), intent(in), optional :: safety_factor_t_f_arg, extending_factor_arg
#@ integer(kind = iint) :: safety_factor_t_f, extending_factor
#@ real(kind = rdouble) :: kmc_time
#@ 
#@ call get_kmc_time(kmc_time)
#@ 
#@ 
#@ if(.not. present(safety_factor_t_f_arg) .or. safety_factor_t_f_arg.eq.0)then
#@ safety_factor_t_f = 2
#@ else
#@ safety_factor_t_f = safety_factor_t_f_arg
#@ end if
#@ 
#@ if(.not. present(extending_factor_arg) .or. extending_factor_arg.eq.0)then
#@ extending_factor = 2
#@ else
#@ extending_factor = extending_factor_arg
#@ end if
#@ t_f = t_f_arg * safety_factor_t_f
#@ t_bin = t_bin_arg
#@ nr_of_bins = int(t_f/t_bin + 1)
#@ extended_nr_of_bins = nr_of_bins * extending_factor
#@ t_f = nr_of_bins * t_bin
#@ allocate(config_bin(extended_nr_of_bins))
#@ config_bin = 0
#@ allocate(counter_write_in_bin(extended_nr_of_bins))
#@ counter_write_in_bin = 0
#@ bin_index = 0
#@ wrap_count = 0
#@ nr_of_annhilations = 0
#@ t_o = kmc_time
#@ 
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Decorrelation time|", t_f, "s"
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Number of bins for ACF|", nr_of_bins
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Total number of bins|", extended_nr_of_bins
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Safety factor decorrelation time|", safety_factor_t_f
#@ print *, "+------------------------------------------------------------+"
#@ print *, "|Extending factor number of bins|", extending_factor
#@ print *, "+------------------------------------------------------------+"
#@
#@
#@ end subroutine allocate_config_bin_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_config_bin_acf(bin_index,return_config_bin)
#@ !****f* base_acf/get_config_bin_acf
#@ ! FUNCTION
#@ !    Returns an entry of the config_bin array.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``bin_index`` positive integer that represents the bin index.
#@ !    * ``return_config_bin`` writeable real, in which the entry of a bin is stored .
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind=iint), intent(in) :: bin_index
#@ real(kind=rdouble), intent(out) :: return_config_bin
#@ 
#@ 
#@ 
#@ return_config_bin = config_bin(bin_index)
#@ 
#@ end subroutine get_config_bin_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_counter_write_in_bin(bin_index,return_counter_write_in_bin)
#@ !****f* base_acf/get_counter_write_in_bin
#@ ! FUNCTION
#@ !    Returns an entry of the config_bin_acf array.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``bin_index`` positive integer that represents the bin index.
#@ !    * ``return_counter_write_in_bin`` writeable integer, in which the number contributions of one bin is stored .
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@
#@ integer(kind=iint), intent(in) :: bin_index
#@ real(kind=rdouble), intent(out) :: return_counter_write_in_bin
#@ 
#@ 
#@ 
#@ return_counter_write_in_bin = counter_write_in_bin(bin_index)
#@ 
#@ end subroutine get_counter_write_in_bin 
#@ 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine set_property_acf(site_nr_acf,input_property_acf)
#@ !****f* base_acf/set_property_acf
#@ ! FUNCTION
#@ !    set_property_acf sets the property of each site for the calculation of ACF.
#@ !    The properties will be stored in property_acf.
#@ !    The properties are defined by the user.
#@ !    The user have to call this subroutine, before the subroutines initialize_acf and allocate_config_bin_acf can be called.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``site_nr_acf`` writeable integer, where site number will be stored.
#@ !    * ``input_property_acf`` writeable real, where the property of the corresponding site will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: site_nr_acf
#@ integer(kind=iint), intent(in) :: input_property_acf
#@ 
#@ 
#@ 
#@ property_acf(site_nr_acf) = input_property_acf
#@ 
#@ end subroutine set_property_acf
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine set_types(type_index,input_property)
#@ !****f* base_acf/set_types
#@ ! FUNCTION
#@ !    def_property_acf defines the property of each site for the calculation of ACF.
#@ !    The properties will be stored in property_acf.
#@ !    The properties are defined by the user.
#@ !    The user have to call this subroutine, before the subroutines initialize_acf and allocate_config_bin_acf can be called.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``site_nr_acf`` writeable integer, where site number will be stored.
#@ !    * ``input_property_acf`` writeable real, where the property of the corresponding site will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: type_index
#@ real(kind=rdouble), intent(in) :: input_property
#@ 
#@ 
#@ 
#@ types(type_index) = input_property
#@ 
#@ end subroutine set_types
#@ 
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine set_product_property(type_index_o,type_index,input_product_property)
#@ !****f* base_acf/set_product_property
#@ ! FUNCTION
#@ !    def_property_acf defines the property of each site for the calculation of ACF.
#@ !    The properties will be stored in property_acf.
#@ !    The properties are defined by the user.
#@ !    The user have to call this subroutine, before the subroutines initialize_acf and allocate_config_bin_acf can be called.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``site_nr_acf`` writeable integer, where site number will be stored.
#@ !    * ``input_property_acf`` writeable real, where the property of the corresponding site will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=iint), intent(in) :: type_index_o
#@ integer(kind=iint), intent(in) :: type_index
#@ real(kind=rdouble), intent(in) :: input_product_property
#@ 
#@ 
#@ 
#@ product_property(type_index_o,type_index) = input_product_property
#@ 
#@ end subroutine set_product_property
#@ 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_property_acf(site,return_property_acf)
#@ !****f* base_acf/get_property_acf
#@ ! FUNCTION
#@ !    Returns the property vector.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_property_acf`` writeable 1 dimensonal array, where the property_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind=iint), intent(in) :: site
#@ integer(kind=iint), intent(out) :: return_property_acf
#@ 
#@ 
#@ 
#@ return_property_acf = property_acf(site)
#@ 
#@ end subroutine get_property_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_types(type_index,return_types)
#@ !****f* base_acf/get_types
#@ ! FUNCTION
#@ !    Returns the property vector.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_property_acf`` writeable 1 dimensonal array, where the property_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind=iint), intent(in) :: type_index
#@ real(kind=rdouble), intent(out) :: return_types
#@ 
#@ 
#@ 
#@ return_types = types(type_index)
#@ 
#@ 
#@ end subroutine get_types
#@ 
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_product_property(type_index_o,type_index,return_product_property)
#@ !****f* base_acf/get_product_property
#@ ! FUNCTION
#@ !    Returns the property vector.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_property_acf`` writeable 1 dimensonal array, where the property_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind=iint), intent(in) :: type_index_o, type_index
#@ real(kind=rdouble), intent(out) :: return_product_property
#@ 
#@ 
#@ 
#@ return_product_property = product_property(type_index_o,type_index)
#@ 
#@ end subroutine get_product_property
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_property_o(particle_id,return_property_o)
#@ !****f* base_acf/get_property_o
#@ ! FUNCTION
#@ !    Returns the property vector.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_property_acf`` writeable 1 dimensonal array, where the property_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind=iint), intent(in) :: particle_id
#@ integer(kind=iint), intent(out) :: return_property_o
#@ 
#@ 
#@ 
#@ return_property_o = property_o(particle_id)
#@ 
#@ end subroutine get_property_o
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_buffer_acf(particle_id,return_buffer_acf)
#@ !****f* base_acf/get_buffer_acf
#@ ! FUNCTION
#@ !    Returns the property vector.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_property_acf`` writeable 1 dimensonal array, where the property_acf will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@
#@ integer(kind=iint), intent(in) :: particle_id 
#@ real(kind=rdouble), intent(out) :: return_buffer_acf
#@ 
#@ 
#@ 
#@ return_buffer_acf = buffer_acf(particle_id)
#@ 
#@ end subroutine get_buffer_acf
#@ 
#@ 
#@ 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_id_arr(site,return_id_arr)
#@ !****f* base_acf/get_id_arr
#@ ! FUNCTION
#@ !    Returns id_arr.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_id_arr`` writeable 2 dimensonal array, where the id_arr will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ 
#@ integer(kind=iint), intent(in) :: site
#@ integer(kind=iint), intent(out) :: return_id_arr
#@ 
#@ return_id_arr = id_arr(site)
#@ 
#@ end subroutine get_id_arr
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine get_site_arr(particle_id,return_site_arr)
#@ !****f* base_acf/get_site_arr
#@ ! FUNCTION
#@ !    Returns site_arr.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_site_arr`` writeable 2 dimensonal array, where the site_arr will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@
#@ integer(kind=iint), intent(in) :: particle_id 
#@ integer(kind=iint), intent(out) :: return_site_arr
#@ 
#@ return_site_arr = site_arr(particle_id)
#@ 
#@ end subroutine get_site_arr
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_trajectory(particle_id,kmc_step,return_trajectory)
#@ !****f* base_acf/get_trajectory
#@ ! FUNCTION
#@ !    Returns the trajectory array.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``return_trajectory`` writeable 2 dimensonal array, where the trajectory from each kMC step will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ 
#@ integer(kind=iint), intent(in) :: particle_id,kmc_step
#@ integer(kind=iint), intent(out) :: return_trajectory
#@ 
#@ return_trajectory = trajectory(particle_id,kmc_step)
#@ 
#@ end subroutine get_trajectory
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine update_trajectory(particle_id, kmc_step_acf)
#@ !****f* base/update_trajectory
#@ ! FUNCTION
#@ !    update_trajectory saves for each particle the property after one kmc step.
#@ !    The property depends on the site, which is occupied by the corresponding particle.
#@ !    This function is optional and can be turned on and off.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle which jumps will be stored.
#@ !    * ``kmc_step_acf`` writeable integer, where the number of kmc steps from the start of the ACF calculation will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint), intent(in) :: particle_id
#@ integer(kind = ilong), intent(in) :: kmc_step_acf
#@ 
#@ 
#@ trajectory(:,kmc_step_acf+1) = trajectory(:,kmc_step_acf)
#@ trajectory(particle_id,kmc_step_acf+1) = site_arr(particle_id)
#@ 
#@ 
#@ end subroutine update_trajectory
#@ 
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine assign_particle_id(init_site,particle_id)
#@ !****f* base_acf/assign_particle_id
#@ ! FUNCTION
#@ !    assign_particle_id gives the id of the particle which jumps, in one kmc step.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint) :: k
#@ integer(kind = iint), intent(out) :: particle_id
#@ integer(kind = iint), intent(in) :: init_site
#@ 
#@ 
#@ 
#@ 
#@ particle_id = id_arr(init_site)
#@ !print *, particle_id
#@ 
#@ end subroutine assign_particle_id
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_displacement(particle_id,displace_coord)
#@ !****f* base_acf/update_displacement
#@ ! FUNCTION
#@ !    update_displacement updates the displacement of the particle, which jumps, in one kmc step.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``displace_coord`` writeable 3 dimensonal array, where the displacement of the jumping particle will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind = iint), intent(in) :: particle_id
#@ real(kind = rdouble), dimension(3), intent(in) :: displace_coord
#@ 
#@ 
#@ displacement(particle_id,:) = displacement(particle_id,:) + displace_coord
#@ 
#@ 
#@ end subroutine update_displacement
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine calc_mean_squared_disp(mean_squared_disp)
#@ !****f* base_acf/calc_mean_squared_disp
#@ ! FUNCTION
#@ !   calc_mean_squared_disp calculates the mean squared displacement after a kmc run.
#@ !   The user have to call this subroutine after the kmc run, to get the mean squared displacement.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``mean_squared_disp`` writeable real, where the mean squared displacement will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ 
#@ integer(kind = iint) :: k
#@ real(kind = rdouble), intent(out) :: mean_squared_disp
#@ 
#@ mean_squared_disp = 0
#@ k = 1
#@ do k = 1, nr_of_ions
#@ mean_squared_disp = mean_squared_disp + sum(displacement(k,:)**2)
#@ enddo
#@ 
#@ mean_squared_disp = mean_squared_disp / nr_of_ions
#@ 
#@ 
#@ end subroutine calc_mean_squared_disp
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine calc_acf(bin_index,return_acf)
#@ !****f* base_acf/calc_acf
#@ ! FUNCTION
#@ !   calc_acf calculates ACF after a kmc run.
#@ !   The user have to call this subroutine after the kmc run, to get the ACF.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``acf`` writeable (nr_of_bins + 1) dimensional array, where the ACF will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ 
#@ integer(kind=iint), intent(in) :: bin_index
#@ real(kind = rdouble), intent(out) :: return_acf
#@ 
#@ 
#@ return_acf = config_bin(bin_index)/(wrap_count*t_bin)
#@ print *, wrap_count
#@ 
#@ 
#@ end subroutine calc_acf
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine update_id_arr(particle_id,init_site,fin_site)
#@ !****f* base_acf/update_id_arr
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied     after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind = iint), intent(in) :: particle_id
#@ integer(kind = iint), intent(in) :: fin_site
#@ integer(kind = iint), intent(in) :: init_site
#@ 
#@ id_arr(init_site) = 0
#@ id_arr(fin_site) = particle_id
#@ site_arr(particle_id) = fin_site
#@ site_arr(0) = 0
#@ 
#@ end subroutine update_id_arr
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine drain_process(exit_site, init_site, fin_site)
#@ !****f* base_acf/drain_process
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind = iint) :: particle_id
#@ integer(kind = iint), intent(in) :: exit_site
#@ integer(kind = iint), intent(out) :: init_site, fin_site
#@ 
#@ 
#@ particle_id = id_arr(exit_site)
#@ site_arr(particle_id) = site_arr(nr_of_ions)
#@  
#@ id_arr(site_arr(particle_id)) = particle_id
#@ site_arr(nr_of_ions) = 0
#@ id_arr(exit_site) = 0
#@ if( property_o(particle_id).ne.0 )then
#@    nr_of_ions_before_kmc_step_acf = nr_of_ions_before_kmc_step_acf - 1 
#@ endif
#@ property_o(particle_id) = property_o(nr_of_ions)
#@ property_o(nr_of_ions) = 0
#@ init_site = site_arr(particle_id)
#@ fin_site = site_arr(particle_id)
#@ buffer_acf(particle_id) = buffer_acf(nr_of_ions)
#@ buffer_acf(nr_of_ions) = 0
#@ nr_of_ions = nr_of_ions - 1
#@ nr_of_annhilations = nr_of_annhilations + 1
#@ 
#@ end subroutine drain_process
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine source_process(entry_site, init_site, fin_site)
#@ !****f* base_acf/source_process
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied     after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind = iint), intent(in) :: entry_site
#@ integer(kind = iint), intent(out) :: init_site, fin_site
#@ 
#@ 
#@ 
#@ nr_of_ions = nr_of_ions + 1
#@ id_arr(entry_site) = nr_of_ions
#@ site_arr(nr_of_ions) = entry_site
#@ fin_site = entry_site
#@ init_site = entry_site
#@ 
#@ end subroutine source_process
#@ 
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_buffer_acf(particle_id)
#@ !****f* base_acf/update_buffer_acf
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied     after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind = iint), intent(in) :: particle_id
#@ 
#@ 
#@ 
#@ buffer_acf(particle_id) = product_property(property_o(particle_id),property_acf(site_arr(particle_id)))
#@ 
#@ 
#@ end subroutine update_buffer_acf
#@ 
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_property_and_buffer_acf()
#@ !****f* base_acf/update_property_and_buffer_acf
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied     after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ integer(kind = iint) :: i, volume
#@ 
#@ call get_volume(volume)
#@ 
#@ 
#@ 
#@ do i = 1, volume
#@ property_o(i) = property_acf(site_arr(i))
#@ buffer_acf(i) = product_property(property_o(i),property_o(i))
#@ enddo
#@ 
#@ end subroutine update_property_and_buffer_acf
#@ 
#@ !------ A. Garhammer 2016------
#@ subroutine update_config_bin()
#@ !****f* base_acf/update_config_bin
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied     after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ real(kind = rdouble) :: entry_bin, kmc_time, kmc_time_step
#@ 
#@ call get_kmc_time(kmc_time)
#@ call get_kmc_time_step(kmc_time_step)
#@ 
#@ entry_bin = sum(buffer_acf)
#@ if(entry_bin.eq.0)then
#@ entry_bin = 0
#@ else
#@ entry_bin = entry_bin/nr_of_ions_before_kmc_step_acf
#@ endif
#@ 
#@ !print *, nr_of_ions_before_kmc_step_acf, entry_bin
#@ 
#@ 
#@ if(kmc_time - t_o < (bin_index + 1) * t_bin)then
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * kmc_time_step
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ else
#@ 
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * ((bin_index + 1) * t_bin - (kmc_time - t_o - kmc_time_step))
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ bin_index = bin_index + 1
#@ if(bin_index < nr_of_bins)then
#@ do while((bin_index + 1) * t_bin < kmc_time - t_o)
#@ 
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * t_bin
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ !print * , bin_index
#@ bin_index = bin_index + 1
#@ 
#@ enddo
#@ !print * , bin_index
#@ config_bin(bin_index + 1) = config_bin(bin_index + 1) + entry_bin * (kmc_time - t_o - (bin_index * t_bin))
#@ counter_write_in_bin(bin_index + 1) = counter_write_in_bin(bin_index + 1) + 1
#@ 
#@ end if
#@ end if
#@ 
#@ 
#@ end subroutine update_config_bin
#@ 
#@ subroutine update_after_wrap_acf()
#@ !****f* base_acf/update_after_wrap_acf
#@ ! FUNCTION
#@ !    update_id_arr updates id_arr after one kmc step.
#@ !    The id of the particle, which jumps, is stored in the entry of id_arr which corresponds to the site, which is occupied     after the jump.
#@ !    The entry of id_arr, which corresponds to the site, which is occupied by the particle before the jump, is setted to zero.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``particle_id`` writeable integer, where the id of the particle, which jumps will be stored.
#@ !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
#@ !    * ``fin_site`` writeable integer, where the number of the site, in which the particle jumps will be stored.
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ real(kind = rdouble) :: kmc_time
#@ 
#@ call get_kmc_time(kmc_time)
#@ 
#@ if(bin_index > nr_of_bins - 1)then
#@ t_o = kmc_time
#@ bin_index = 0
#@ wrap_count = wrap_count + 1
#@ call update_property_and_buffer_acf()
#@ call update_nr_of_ions_before_kmc_step_acf()
#@ end if
#@ 
#@ end subroutine update_after_wrap_acf 
#@
#@
#@ !------ A. Garhammer 2015------
#@ subroutine update_kmc_step_acf()
#@ !****f* base_acf/update_kmc_step_acf
#@ ! FUNCTION
#@ !    Updates kmc_step_acf
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``None`` Writeable integer
#@ !******
#@ !---------------I/O variables---------------
#@ 
#@ 
#@ kmc_step_acf = kmc_step_acf + 1
#@ 
#@ end subroutine update_kmc_step_acf
#@
#@ 
#@ !------ A. Garhammer 2015------
#@ subroutine get_kmc_step_acf(return_kmc_step_acf)
#@ !****f* base_acf/get_kmc_step_acf
#@ ! FUNCTION
#@ !    Return the current kmc_step_acf
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``kmc_step_acf`` Writeable integer
#@ !******
#@ !---------------I/O variables---------------
#@ integer(kind=ilong), intent(out) :: return_kmc_step_acf
#@ 
#@ return_kmc_step_acf = kmc_step_acf
#@ 
#@ end subroutine get_kmc_step_acf
#@ 
#@ 
#@ 
#@ end module base_acf
