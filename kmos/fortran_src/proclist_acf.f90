!  This file was generated by kMOS (kMC modelling on steroids)
!  written by Max J. Hoffmann mjhoffmann@gmail.com (C) 2009-2013.
!  The model was written by Andreas Garhammer.

!  This file is part of kmos.
!
!  kmos is free software; you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation; either version 2 of the License, or
!  (at your option) any later version.
!
!  kmos is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with kmos; if not, write to the Free Software
!  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
!  USA
!****h* kmos/proclist
! FUNCTION
!    Implements the kMC process list.
!
!******


module proclist_acf
use kind_values
use base, only: &
    update_accum_rate, &
    update_integ_rate, &
    determine_procsite, &
    update_clocks, &
    avail_sites, &
    null_species, &
    increment_procstat

use base_acf, only: &
    assign_particle_id, &
    update_id_arr, &
    update_displacement, &
    update_config_bin,&
    update_buffer_acf, &
    update_property_and_buffer_acf, &
    drain_process, &
    source_process, &
    update_after_wrap_acf


use lattice, only: &
    default, &
    default_a_1, &
    default_a_2, &
    default_b_1, &
    default_b_2, &
    default_source_site, &
    allocate_system, &
    nr2lattice, &
    lattice2nr, &
    add_proc, &
    can_do, &
    set_rate_const, &
    replace_species, &
    del_proc, &
    reset_site, &
    system_size, &
    spuck, &
    get_species, &
    site_positions, &
    unit_cell_size


use proclist

implicit none





contains

subroutine do_kmc_steps_acf(n)

!****f* proclist/do_kmc_steps_acf
! FUNCTION
!    Performs ``n`` kMC step for the on the fly calculation of the autocorrelation function (ACF).
!    If one has to run many steps without evaluation
!    do_kmc_steps might perform a little better.
!    * first update clock
!    * then configuration sampling step
!    * last execute process
!
! ARGUMENTS
!
!    ``n`` : Number of steps to run
!******
    integer(kind=iint), intent(in) :: n

    real(kind=rsingle) :: ran_proc, ran_time, ran_site
    integer(kind=iint) :: nr_site, proc_nr, i, particle, init_site, fin_site
    
    do i = 1, n
    call random_number(ran_time)
    call random_number(ran_proc)
    call random_number(ran_site)
    call update_accum_rate
    call update_clocks(ran_time)
    call update_integ_rate
    call determine_procsite(ran_proc, ran_site, proc_nr, nr_site)
    call update_config_bin()
    call get_diff_sites_acf(proc_nr, nr_site, init_site, fin_site)
    call assign_particle_id(init_site, particle)
    call update_id_arr(particle,init_site, fin_site)
    call update_after_wrap_acf
    call run_proc_nr(proc_nr, nr_site)
    call update_buffer_acf(particle)
    enddo
    
end subroutine do_kmc_steps_acf

!------ A. Garhammer 2016------
subroutine do_kmc_step_acf()

!****f* proclist/do_kmc_step
! FUNCTION
!    Performs exactly one kMC step for the on the fly calculation of the autocorrelation function (ACF).
!    *  first update clock
!    *  then configuration sampling step
!    *  last execute process
!
! ARGUMENTS
!
!    ``none``
!******
    real(kind=rsingle) :: ran_proc, ran_time, ran_site
    integer(kind=iint) :: nr_site, proc_nr, particle, init_site, fin_site
    
    call random_number(ran_time)
    call random_number(ran_proc)
    call random_number(ran_site)
    call update_accum_rate
    call update_clocks(ran_time)
    call update_integ_rate
    call determine_procsite(ran_proc, ran_site, proc_nr, nr_site)
    call update_config_bin()
    call get_diff_sites_acf(proc_nr, nr_site, init_site, fin_site) 
    call assign_particle_id(init_site, particle)
    call update_id_arr(particle,init_site, fin_site)
    call update_after_wrap_acf
    call run_proc_nr(proc_nr, nr_site)
    call update_buffer_acf(particle)
   
end subroutine do_kmc_step_acf

!------ A. Garhammer 2016------
subroutine do_kmc_steps_displacement(n)

!****f* proclist/do_kmc_steps
! FUNCTION
!    Performs ``n`` kMC step for the calculation of mean squared displacement.
!    If one has to run many steps without evaluation
!    do_kmc_steps might perform a little better.
!    * first update clock
!    * then configuration sampling step
!    * last execute process
!
! ARGUMENTS
!
!    ``n`` : Number of steps to run
!******
    integer(kind=iint), intent(in) :: n

    real(kind=rsingle) :: ran_proc, ran_time, ran_site
    integer(kind=iint) :: nr_site, proc_nr, i, particle, init_site, fin_site
    real(kind=rdouble), dimension(3) :: displace_coord
    do i = 1, n
    call random_number(ran_time)
    call random_number(ran_proc)
    call random_number(ran_site)
    call update_accum_rate
    call update_clocks(ran_time)
    call update_integ_rate
    call determine_procsite(ran_proc, ran_site, proc_nr, nr_site)
    call get_diff_sites_displacement(proc_nr, nr_site, init_site, fin_site,displace_coord) 
    call assign_particle_id(init_site, particle)
    call update_displacement(particle, displace_coord)
    call update_id_arr(particle,init_site, fin_site)
    call run_proc_nr(proc_nr, nr_site)
    enddo
    
end subroutine do_kmc_steps_displacement

!------ A. Garhammer 2016------
subroutine do_kmc_step_displacement()

!****f* proclist/do_kmc_step
! FUNCTION
!    Performs exactly one kMC step for the calculation of mean squared displacement.
!    *  first update clock
!    *  then configuration sampling step
!    *  last execute process
!
! ARGUMENTS
!
!    ``none``
!******
    real(kind=rsingle) :: ran_proc, ran_time, ran_site
    integer(kind=iint) :: nr_site, proc_nr, particle, init_site, fin_site
    real(kind=rdouble), dimension(3) :: displace_coord
    call random_number(ran_time)
    call random_number(ran_proc)
    call random_number(ran_site)
    call update_accum_rate
    call update_clocks(ran_time)
    call update_integ_rate
    call determine_procsite(ran_proc, ran_site, proc_nr, nr_site)
    call get_diff_sites_displacement(proc_nr, nr_site, init_site, fin_site,displace_coord) 
    call assign_particle_id(init_site, particle)
    call update_displacement(particle, displace_coord)
    call update_id_arr(particle,init_site, fin_site)
    call run_proc_nr(proc_nr, nr_site)
    
    
end subroutine do_kmc_step_displacement


!------ A. Garhammer 2016------
subroutine get_diff_sites_acf(proc,nr_site,init_site,fin_site)
    
    !****f* proclist/get_diff_sites_acf
    ! FUNCTION
    !    get_diff_sites_acf gives the number of site, from which the particle jumps away (init_site) 
    !    and also the site (fin_site) in which the particle jumps.
    !
    ! ARGUMENTS
    !
    !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
    !    * ``fin_site``  writeable integer, where the number of the site, in which the particle jumps will be stored.
    !******
    integer(kind=iint), intent(in) :: proc
    integer(kind=iint), intent(in) :: nr_site
    integer(kind=iint), intent(out) :: init_site, fin_site
    integer(kind=iint), dimension(4) :: lsite
    integer(kind=iint), dimension(4) :: lsite_new
    integer(kind=iint), dimension(4) :: lsite_old
    integer(kind=iint) :: exit_site, entry_site
    
    lsite = nr2lattice(nr_site, :)
     
     select case(proc)
     case(a_1_a_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_a_2 - default_a_1/)
         fin_site =  lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         
     case(a_1_b_1)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_1 - default_a_1/)
         fin_site =  lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         
     case(a_1_b_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_2 - default_a_1/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         
     case(a_2_a_1)
        
         lsite_old = lsite + (/0, 0, 0, default_a_2 - default_a_1/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         
     case(a_2_b_1)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_1 - default_a_2/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         
      
      case(a_2_b_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_2 - default_a_2/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         
      case(b_1_a_1)
        
          lsite_old = lsite + (/0, 0, 0, default_b_1 - default_a_1/)
          init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
          fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
          
     case(b_1_a_2)
        
         lsite_old = lsite + (/0, 0, 0, default_b_1 - default_a_2/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         
     case(b_1_b_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_2 - default_b_1/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         
     case(b_2_a_1)
        
         lsite_old = lsite + (/0, 0, 0, default_b_2 - default_a_1/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         
     case(b_2_a_2)
       
         lsite_old = lsite + (/0, 0, 0, default_b_2 - default_a_2/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         
     case(b_2_b_1)
        
         lsite_old = lsite + (/0, 0, 0, default_b_2 - default_b_1/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
     
     case(entry_process)
         
         entry_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4)) 
         call source_process(entry_site, init_site, fin_site)    
           
     case(exit_process)
       
         exit_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         call drain_process(exit_site, init_site, fin_site)

     end select

end subroutine get_diff_sites_acf

!------ A. Garhammer 2016------
subroutine get_diff_sites_displacement(proc,nr_site,init_site,fin_site,displace_coord)
    
    !****f* proclist/get_diff_sites_displacement
    ! FUNCTION
    !    get_diff_sites_acf gives the number of site, from which the particle jumps away (init_site) 
    !    and also the site (fin_site) in which the particle jumps.
    !    Additionally, the displacement of the jumping particle will be saved.
    !
    ! ARGUMENTS
    !
    !    * ``init_site`` writeable integer, where the number of the site, from which the particle jumps away will be stored.
    !    * ``fin_site``  writeable integer, where the number of the site, in which the particle jumps will be stored.
    !    * ``displace_coord`` writeable 3 dimensonal array, where the displacement of the jumping particle will be stored.
    !
    !******
    integer(kind=iint), intent(in) :: proc
    integer(kind=iint), intent(in) :: nr_site
    integer(kind=iint), intent(out) :: init_site, fin_site
    integer(kind=iint), dimension(4) :: lsite
    integer(kind=iint), dimension(4) :: lsite_new
    integer(kind=iint), dimension(4) :: lsite_old
    real(kind=rdouble), dimension(3), intent(out) :: displace_coord
    
    lsite = nr2lattice(nr_site, :)
     
     select case(proc)
     case(a_1_a_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_a_2 - default_a_1/)
         fin_site =  lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_a_2,:) - site_positions(default_a_1,:)))
     
     case(a_1_b_1)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_1 - default_a_1/)
         fin_site =  lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_b_1,:) - site_positions(default_a_1,:)))
     
     case(a_1_b_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_2 - default_a_1/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_b_2,:) - site_positions(default_a_1,:)))
     
     case(a_2_a_1)
        
         lsite_old = lsite + (/0, 0, 0, default_a_2 - default_a_1/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_a_1,:) - site_positions(default_a_2,:)))
     
     case(a_2_b_1)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_1 - default_a_2/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_b_1,:) - site_positions(default_a_2,:)))
      
     case(a_2_b_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_2 - default_a_2/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_b_2,:) - site_positions(default_a_2,:)))
      

     case(b_1_a_1)
          lsite_old = lsite + (/0, 0, 0, default_b_1 - default_a_1/)
          init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
          fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
          displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_a_1,:) - site_positions(default_b_1,:)))
     
     case(b_1_a_2)
        
         lsite_old = lsite + (/0, 0, 0, default_b_1 - default_a_2/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_a_2,:) - site_positions(default_b_1,:)))
     
     case(b_1_b_2)
        
         init_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         lsite_new = lsite + (/0, 0, 0, default_b_2 - default_b_1/)
         fin_site = lattice2nr(lsite_new(1),lsite_new(2),lsite_new(3),lsite_new(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_b_2,:) - site_positions(default_b_1,:)))
     
     case(b_2_a_1)
        
         lsite_old = lsite + (/0, 0, 0, default_b_2 - default_a_1/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_a_1,:) - site_positions(default_b_2,:)))
     
     case(b_2_a_2)
       
         lsite_old = lsite + (/0, 0, 0, default_b_2 - default_a_2/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_a_2,:) - site_positions(default_b_2,:)))
     
     case(b_2_b_1)
        
         lsite_old = lsite + (/0, 0, 0, default_b_2 - default_b_1/)
         init_site = lattice2nr(lsite_old(1),lsite_old(2),lsite_old(3),lsite_old(4))
         fin_site = lattice2nr(lsite(1),lsite(2),lsite(3),lsite(4))
         displace_coord = matmul(unit_cell_size,(/0,0,0/) + (site_positions(default_b_1,:) - site_positions(default_b_2,:)))
     end select

end subroutine get_diff_sites_displacement



end module proclist_acf
