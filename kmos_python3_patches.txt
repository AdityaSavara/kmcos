diff --git a/doc/source/conf.py b/doc/source/conf.py
index 53e8d68..787d7c2 100644
--- a/doc/source/conf.py
+++ b/doc/source/conf.py
@@ -43,8 +43,8 @@ source_suffix = '.rst'
 master_doc = 'index'
 
 # General information about the project.
-project = u'kmos'
-copyright = u'2009-2013, Max J. Hoffmann'
+project = 'kmos'
+copyright = '2009-2013, Max J. Hoffmann'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
@@ -179,8 +179,8 @@ latex_font_size = '10pt'
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title, author, documentclass [howto/manual]).
 latex_documents = [
-  ('index', 'kmos.tex', u'kmos Documentation',
-   u'Max J. Hoffmann', 'manual'),
+  ('index', 'kmos.tex', 'kmos Documentation',
+   'Max J. Hoffmann', 'manual'),
 ]
 
 # The name of an image file (relative to this directory) to place at the top of
diff --git a/examples/AB_model.py b/examples/AB_model.py
index fe83514..c523ebc 100755
--- a/examples/AB_model.py
+++ b/examples/AB_model.py
@@ -40,7 +40,7 @@ def main():
     parameters['E_react'] = {'value': 0.9}
 
 
-    for key, value in parameters.iteritems():
+    for key, value in parameters.items():
         pt.add_parameter(name=key, **value)
 
 
diff --git a/examples/run_in_multi_process.py b/examples/run_in_multi_process.py
index fa420ed..2267e58 100755
--- a/examples/run_in_multi_process.py
+++ b/examples/run_in_multi_process.py
@@ -43,7 +43,7 @@ def run(point):
 
         # Run simulation
         last_time = 0.
-        for double_step in xrange(3):
+        for double_step in range(3):
             last_time = model.base.get_kmc_time()
             model.double()
             model.base.set_kmc_time(last_time)
@@ -55,7 +55,7 @@ def run(point):
         occupation = []
         tof = []
         delta_ts = []
-        for i in xrange(SAMPLES):
+        for i in range(SAMPLES):
             model.do_steps()
             atoms = model.get_atoms(geometry=False)
 
@@ -79,4 +79,4 @@ if __name__ == '__main__':
     p_O2gas = [1.] * len(p_COgas)
     nproc = 8
     pool = Pool(processes=nproc)
-    pool.map(run, zip(T, p_COgas, p_O2gas))
+    pool.map(run, list(zip(T, p_COgas, p_O2gas)))
diff --git a/kmos/__init__.py b/kmos/__init__.py
index 1aabcc6..69d5332 100644
--- a/kmos/__init__.py
+++ b/kmos/__init__.py
@@ -67,7 +67,7 @@ def evaluate_rate_expression(rate_expr, parameters={}):
         parameters = [Parameter(), ... ]
      """
     import tokenize
-    import StringIO
+    import io
     import math
     from kmos import units
 
@@ -84,10 +84,10 @@ def evaluate_rate_expression(rate_expr, parameters={}):
         replaced_tokens = []
 
         # replace some aliases
-        for old, new in rate_aliases.iteritems():
+        for old, new in rate_aliases.items():
             rate_expr = rate_expr.replace(old, new)
         try:
-            input = StringIO.StringIO(rate_expr).readline
+            input = io.StringIO(rate_expr).readline
             tokens = list(tokenize.generate_tokens(input))
         except:
             raise Exception('Could not tokenize expression: %s' % input)
@@ -140,7 +140,7 @@ def evaluate_rate_expression(rate_expr, parameters={}):
         rate_expr = tokenize.untokenize(replaced_tokens)
         try:
             rate_const = eval(rate_expr)
-        except Exception, e:
+        except Exception as e:
             raise UserWarning(
             "Could not evaluate rate expression: %s\nException: %s" \
                 % (rate_expr, e))
diff --git a/kmos/cli.py b/kmos/cli.py
index 71d95bd..ad69b12 100644
--- a/kmos/cli.py
+++ b/kmos/cli.py
@@ -39,7 +39,7 @@
 #    You should have received a copy of the GNU General Public License
 #    along with kmos.  If not, see <http://www.gnu.org/licenses/>.
 
-from __future__ import with_statement
+
 import os
 import shutil
 
@@ -270,7 +270,7 @@ def main(args=None):
 
     global model, pt, np, cm_model
 
-    if not args[0] in usage.keys():
+    if not args[0] in list(usage.keys()):
         args[0] = match_keys(args[0], usage, parser)
 
     if args[0] == 'benchmark':
@@ -352,7 +352,7 @@ def main(args=None):
                     if options.overwrite :
                         overwrite = 'y'
                     else:
-                        overwrite = raw_input(('Should I overwrite existing %s ?'
+                        overwrite = input(('Should I overwrite existing %s ?'
                                                '[y/N]  ') % out).lower()
                     if overwrite.startswith('y') :
                         print('Overwriting {out}'.format(**locals()))
diff --git a/kmos/gui/__init__.py b/kmos/gui/__init__.py
index e5c2d6b..3a08edc 100644
--- a/kmos/gui/__init__.py
+++ b/kmos/gui/__init__.py
@@ -19,7 +19,7 @@
 
 # standard modules
 import optparse
-import StringIO
+import io
 import sys
 import os
 
@@ -77,17 +77,17 @@ menu_layout = """\
 def verbose(func):
     """Debugging helper that allows to track input and output of function
     via decoration"""
-    print >> sys.stderr, "monitor %r" % (func.func_name)
+    print >> sys.stderr, "monitor %r" % (func.__name__)
 
     def wrapper_func(*args, **kwargs):
         """The wrapping function
         """
         print >> sys.stderr, "call(\033[0;31m%s.%s\033[0;30m): %r\n" % \
-                (type(args[0]).__name__, func.func_name, args[1:]), \
+                (type(args[0]).__name__, func.__name__, args[1:]), \
                 sys.stderr.flush()
         ret = func(*args, **kwargs)
         print >> sys.stderr, "    ret(%s): \033[0;32m%r\033[0;30m\n" % \
-                 (func.func_name, ret)
+                 (func.__name__, ret)
         return ret
     return wrapper_func
 
@@ -359,7 +359,7 @@ class UndoStack():
                         '/MainMenuBar/MenuEdit/EditRedo').set_sensitive(False)
 
     def _set_state_cb(self, string):
-        tmpfile = StringIO.StringIO()
+        tmpfile = io.StringIO()
         tmpfile.write(string)
         tmpfile.seek(0)
         self.set_state_from_file_cb(tmpfile)
@@ -484,7 +484,7 @@ class Editor(GladeDelegate):
         self.menubar.insert_action_group(actions, 0)
         try:
             mergeid = self.menubar.add_ui_from_string(menu_layout)
-        except gobject.GError, error:
+        except gobject.GError as error:
             print('Building menu failed: %s, %s' % (error, mergeid))
 
         # Initialize the project tree, passing in the menu bar
@@ -592,7 +592,7 @@ class Editor(GladeDelegate):
         """
         if len(self.project_tree.layer_list) == 1:
             kiwi.ui.dialogs.warning('Entering multi-lattice mode',
-                long='This is an unpublished feature\n' +
+                int='This is an unpublished feature\n' +
                 'Please ask me about publishing results obtained\n' +
                 'from using this feature mjhoffmann@gmail.com')
         if self.project_tree.meta.model_dimension in [1, 3]:
diff --git a/kmos/gui/forms.py b/kmos/gui/forms.py
index 5b2a975..0974dfc 100644
--- a/kmos/gui/forms.py
+++ b/kmos/gui/forms.py
@@ -585,7 +585,7 @@ class ProcessForm(ProxySlaveDelegate, CorrectlyNamed):
                     'Current value: %.5e s^{-1}' %
                     evaluate_rate_expression(expr,
                         self.project_tree.get_parameters()))
-            except Exception, e:
+            except Exception as e:
                 self.rate_constant.set_tooltip_text(str(e))
         rate_constant_terms = ['bar',
                                'beta',
@@ -623,7 +623,7 @@ class ProcessForm(ProxySlaveDelegate, CorrectlyNamed):
             self.rate_constant.set_tooltip_text('Current value: %.2e s^{-1}' %
                 evaluate_rate_expression(expr,
                     self.project_tree.get_parameters()))
-        except Exception, e:
+        except Exception as e:
             return ValidationError(e)
 
     def on_chemical_expression__activate(self, entry):
@@ -649,7 +649,7 @@ class ProcessForm(ProxySlaveDelegate, CorrectlyNamed):
             parse_chemical_expression(eq=text,
                                       process=self.process,
                                       project_tree=self.project_tree)
-        except Exception, e:
+        except Exception as e:
             # first remove last term and try again
             try:
                 print("Error ...")
@@ -663,7 +663,7 @@ class ProcessForm(ProxySlaveDelegate, CorrectlyNamed):
                                           process=self.process,
                                           project_tree=self.project_tree)
 
-            except Exception, e:
+            except Exception as e:
                 print("Fatal Error ... %s" % e)
                 self.process.condition_list = []
                 self.process.action_list = []
diff --git a/kmos/io.py b/kmos/io.py
index 9caaee0..0970293 100644
--- a/kmos/io.py
+++ b/kmos/io.py
@@ -26,6 +26,8 @@ import os
 import sys
 import copy
 import numpy as np
+#NB needed for sorted without cmp argument
+import functools
 
 from pprint import pformat
 
@@ -42,7 +44,7 @@ def _casetree_dict(dictionary, indent='', out=None):
     # at the end of a 'select case' statement.
     # Thus we use reversed() to move the 'default'
     # branch from the beginning to the end.
-    for key, value in reversed(list(dictionary.iteritems())):
+    for key, value in reversed(list(dictionary.items())):
         if isinstance(value, dict):
             if isinstance(key, Coord):
                 out.write('%sselect case(get_species(cell%s))\n' % (indent, key.radd_ff()))
@@ -51,7 +53,7 @@ def _casetree_dict(dictionary, indent='', out=None):
             else:
                 if key != 'default':
                     # allowing for or in species
-                    keys = ', '.join(map(lambda x: x.strip(), key.split(' or ')))
+                    keys = ', '.join([x.strip() for x in key.split(' or ')])
                     out.write('%scase(%s)\n' % (indent, keys))
                     _casetree_dict(value, indent + '  ', out)
                 else:
@@ -63,7 +65,7 @@ def _casetree_dict(dictionary, indent='', out=None):
 def _print_dict(dictionary, indent = ''):
     """ Recursively prints nested dictionaries."""
 
-    for key, value in dictionary.iteritems():
+    for key, value in dictionary.items():
         if isinstance(value, dict):
             print('%s%s:' % (indent, key) )
             _print_dict(value, indent+'    ')
@@ -1267,21 +1269,23 @@ class ProcListWriter():
         ################################################################
         lat_int_groups = {}
         for process in process_list:
-            for lat_int_group, processes in lat_int_groups.iteritems():
+            for lat_int_group, processes in lat_int_groups.items():
                 p0 = processes[0]
                 same = True
                 # check if conditions are identical
-                if sorted(p0.condition_list, key=lambda x: x.coord, cmp=cmp_coords) \
-                   != sorted(process.condition_list, key=lambda x: x.coord, cmp=cmp_coords):
+                #NB if sorted(p0.condition_list, key=lambda x: x.coord, cmp=cmp_coords) \
+                #NB replace with functools.cmp_to_key based syntax
+                if sorted(p0.condition_list, key=functools.cmp_to_key(lambda a, b : cmp_coords(a.coord,b.coord))) \
+                   != sorted(process.condition_list, key=functools.cmp_to_key(lambda a, b : cmp_coords(a.coord,b.coord))):
                     same = False
                 # check if actions are identical
-                if sorted(p0.action_list, key=lambda x: x.coord, cmp=cmp_coords) \
-                   != sorted(process.action_list, key=lambda x: x.coord, cmp=cmp_coords):
+                if sorted(p0.action_list, key=functools.cmp_to_key(lambda a, b : cmp_coords(a.coord,b.coord))) \
+                   != sorted(process.action_list, key=functools.cmp_to_key(lambda a, b : cmp_coords(a.coord,b.coord))):
                     same = False
 
                 # check if coords of bystanders are identical
-                if [x.coord for x in sorted(p0.bystanders, key=lambda x: x.coord, cmp=cmp_coords)] \
-                   != [x.coord for x in sorted(process.bystanders, key=lambda x: x.coord, cmp=cmp_coords)]:
+                if [x.coord for x in sorted(p0.bystanders, key=functools.cmp_to_key(lambda a, b : cmp_coords(a.coord,b.coord)))] \
+                   != [x.coord for x in sorted(process.bystanders, key=functools.cmp_to_key(lambda a, b : cmp_coords(a.coord,b.coord)))]:
                     same = False
 
                 if same:
@@ -1413,7 +1417,7 @@ class ProcListWriter():
             out.write('    print *, "  PROCLIST/RUN_PROC_NR/NR_CELL", nr_cell\n')
             out.write('    print *, "  PROCLIST/RUN_PROC_NR/CELL", cell\n')
         out.write('    select case(proc)\n')
-        for lat_int_group, processes in lat_int_groups.iteritems():
+        for lat_int_group, processes in lat_int_groups.items():
             proc_names = ', '.join([proc.name for proc in processes])
             out.write('    case(%s)\n' % _chop_line(proc_names, line_length=60))
             out.write('        call run_proc_%s(cell)\n' % lat_int_group)
@@ -1445,7 +1449,7 @@ class ProcListWriter():
         out.write('        endif\n')
         out.write('    end do\n\n')
 
-        for lat_int_group, process in lat_int_groups.iteritems():
+        for lat_int_group, process in lat_int_groups.items():
             out.write('    call add_proc(nli_%s(cell), site)\n' % (lat_int_group))
         out.write('end subroutine touchup_cell\n\n')
 
@@ -1458,7 +1462,7 @@ class ProcListWriter():
         for a given process.
         """
 
-        for lat_int_loop, (lat_int_group, processes) in enumerate(lat_int_groups.iteritems()):
+        for lat_int_loop, (lat_int_group, processes) in enumerate(lat_int_groups.items()):
             out = open('%s/run_proc_%04d.f90' % (self.dir, lat_int_loop), 'w')
             self._db_print('PROCESS: %s' % lat_int_group)
             # initialize needed data structure
@@ -1482,7 +1486,7 @@ class ProcListWriter():
             # add "another process" to the processes to be modified/updated.
             for action in process0.action_list:
                 self._db_print('    ACTION: %s' % action)
-                for _, other_processes in lat_int_groups.iteritems():
+                for _, other_processes in lat_int_groups.items():
                     other_process = other_processes[0]
                     self._db_print('      OTHER PROCESS %s' % (pformat(other_process, indent=12)))
                     other_conditions = other_process.condition_list + other_process.bystanders
@@ -1512,7 +1516,7 @@ class ProcListWriter():
                 try:
                     action = [action for action in process0.action_list
                                             if condition.coord == action.coord][0]
-                except Exception, e:
+                except Exception as e:
                     print(e)
                     print('Trouble with process %s' % process.name)
                     print('And condition %s' % condition)
@@ -1533,7 +1537,7 @@ class ProcListWriter():
                 if len(condition_species.split(' or ') ) > 1 :
                     out.write('    select case(get_species((cell%s)))\n'
                               % (action.coord.radd_ff(),))
-                    for condition_species in map(lambda x: x.strip(), condition_species.split(' or ')):
+                    for condition_species in [x.strip() for x in condition_species.split(' or ')]:
                         out.write('    case(%s)\n' % condition_species)
                         out.write('    call replace_species(cell%s, %s, %s)\n'
                                   % (action.coord.radd_ff(),
@@ -1565,7 +1569,7 @@ class ProcListWriter():
                     if len(condition_species.split(' or ') ) > 1 :
                         out.write('    select case(get_species((cell%s)))\n'
                                   % (action.coord.radd_ff(),))
-                        for condition_species in map(lambda x: x.strip(), condition_species.split(' or ')):
+                        for condition_species in [x.strip() for x in condition_species.split(' or ')]:
                             out.write('    case(%s)\n' % condition_species)
                             out.write('            call replace_species(cell%s, %s, %s)\n'
                                       % (action.coord.radd_ff(),
@@ -1608,7 +1612,7 @@ class ProcListWriter():
 
         """
 
-        for lat_int_loop, (lat_int_group, processes) in enumerate(lat_int_groups.iteritems()):
+        for lat_int_loop, (lat_int_group, processes) in enumerate(lat_int_groups.items()):
             out = open('%s/nli_%04d.f90' % (self.dir, lat_int_loop), 'w')
             out.write('module nli_%04d\n' % lat_int_loop)
             out.write('use kind_values\n')
@@ -1641,8 +1645,9 @@ class ProcListWriter():
             # the needed conditions as parent nodes
             case_tree = {}
             for process in processes:
+                #NB
                 conditions = [y for y in sorted(process.condition_list + process.bystanders,
-                                                 key=lambda x: x.coord, cmp=cmp_coords)
+                                                 key=functools.cmp_to_key(lambda a,b : cmp_coords(a.coord,b.coord)))
                                                  if not y.implicit]
                 node = case_tree
                 for condition in conditions:
@@ -1681,7 +1686,7 @@ class ProcListWriter():
 
         """
 
-        for lat_int_loop, (lat_int_group, processes) in enumerate(lat_int_groups.iteritems()):
+        for lat_int_loop, (lat_int_group, processes) in enumerate(lat_int_groups.items()):
             process0 = processes[0]
 
             # put together the bystander conditions and true conditions,
@@ -1728,7 +1733,7 @@ class ProcListWriter():
                     lat_int_nr += species_nr*(nr_of_species**j)
                     #print(lat_int_nr, species.name, nr_of_species, j)
                 compression_map[lat_int_nr] = process.name
-                if lat_int_nr > sys.maxint :
+                if lat_int_nr > sys.maxsize :
                     print(("Warning: Lateral interaction index is too large to compile.\n"
                           "          Try to reduce the number of (non-implicit conditions\n"
                           "          or the total number of species.\n\n%s") % process)
@@ -1743,7 +1748,7 @@ class ProcListWriter():
             # use generator object to save memory
             if USE_ARRAY:
                 compression_index = (compression_map.get(i, 0) for
-                                     i in xrange(nr_of_species**len(conditions0)))
+                                     i in range(nr_of_species**len(conditions0)))
                 out.write('    integer, dimension(%s), parameter :: lat_int_index_%s = (/ &\n'
                           % (len(compression_index), lat_int_group))
                 outstr = ', '.join(map(str, compression_index))
@@ -1767,7 +1772,7 @@ class ProcListWriter():
                           % (lat_int_group, lat_int_group))
             else:
                 out.write('\n    select case(n)\n')
-                for i, proc_name in sorted(compression_map.iteritems()):
+                for i, proc_name in sorted(compression_map.items()):
                     if proc_name:
                         out.write('    case(%s)\n' % i)
                         out.write('        nli_%s = %s\n' %
@@ -1853,7 +1858,7 @@ class ProcListWriter():
 
                                         # filter out the current condition, because we know we set it to true
                                         # right now
-                                        other_conditions = filter(lambda x: x.coord != condition.coord, process.condition_list)
+                                        other_conditions = [x for x in process.condition_list if x.coord != condition.coord]
                                         # note how '-' operation is defined for Coord class !
                                         # we change the coordinate part to already point at
                                         # the right relative site
@@ -1952,9 +1957,8 @@ class ProcListWriter():
                             out.write('    call replace_species(site, species, null_species)\n\n')
 
                         for process in data.process_list:
-                            for condition in filter(lambda condition: condition.coord.name == site.name and
-                                                                      condition.coord.layer == layer.name,
-                                                                      process.condition_list):
+                            for condition in [condition for condition in process.condition_list if condition.coord.name == site.name and
+                                                                      condition.coord.layer == layer.name]:
                                 if special_op == 'create':
                                     other_conditions = [ConditionAction(
                                             species=other_condition.species,
@@ -1997,7 +2001,7 @@ class ProcListWriter():
         # So consider this a heuristic solution which should give
         # on average better results than the brute force way
 
-        for item in filter(lambda x: not x[0], items):
+        for item in [x for x in items if not x[0]]:
             # [1][2] field of the item determine if this search is intended for enabling (=True) or
             # disabling (=False) a process
             if item[1][2]:
@@ -2006,7 +2010,7 @@ class ProcListWriter():
                 out.write('%scall del_proc(%s, %s)\n' % (' ' * indent, item[1][0], item[1][1]))
 
         # and only keep those that have conditions
-        items = filter(lambda x: x[0], items)
+        items = [x for x in items if x[0]]
         if not items:
             return
 
@@ -2015,7 +2019,7 @@ class ProcListWriter():
         most_common_coord = _most_common([y.coord for y in _flatten([x[0] for x in items])])
 
         # filter out list of uniq answers for this site
-        answers = [y.species for y in filter(lambda x: x.coord == most_common_coord, _flatten([x[0] for x in items]))]
+        answers = [y.species for y in [x for x in _flatten([x[0] for x in items]) if x.coord == most_common_coord]]
         uniq_answers = list(set(answers))
 
         if self.data.meta.debug > 1:
@@ -2028,18 +2032,16 @@ class ProcListWriter():
             out.write('%scase(%s)\n' % ((indent) * ' ', answer))
             # this very crazy expression matches at items that contain
             # a question for the same coordinate and have the same answer here
-            nested_items = filter(
-                lambda x: (most_common_coord in [y.coord for y in x[0]]
-                and answer == filter(lambda y: y.coord == most_common_coord, x[0])[0].species),
-                items)
+            nested_items = [x for x in items if (most_common_coord in [y.coord for y in x[0]]
+                and answer == filter(lambda y: y.coord == most_common_coord, x[0])[0].species)]
             # pruned items are almost identical to nested items, except the have
             # the one condition removed, that we just met
             pruned_items = []
             for nested_item in nested_items:
-                conditions = filter(lambda x: most_common_coord != x.coord, nested_item[0])
+                conditions = [x for x in nested_item[0] if most_common_coord != x.coord]
                 pruned_items.append((conditions, nested_item[1]))
 
-            items = filter(lambda x: x not in nested_items, items)
+            items = [x for x in items if x not in nested_items]
             self._write_optimal_iftree(pruned_items, indent + 4, out)
         out.write('%send select\n\n' % (indent * ' ',))
 
@@ -2055,7 +2057,7 @@ class ProcListWriter():
         handles rate constants update at fortran level'''
 
         import tokenize
-        import StringIO
+        import io
         import itertools
         from kmos import evaluate_rate_expression
         from kmos import rate_aliases
@@ -2160,13 +2162,13 @@ class ProcListWriter():
             specs_dict = {}
             for byst in process.bystander_list:
                 for flg in byst.flag.split():
-                    if specs_dict.has_key(flg):
+                    if flg in specs_dict:
                         specs_dict[flg].extend(byst.allowed_species)
                     else:
                         specs_dict[flg] = copy.deepcopy(byst.allowed_species)
                     flags.append(flg)
             flags = sorted(list(set(flags)))
-            for flg,spclist in specs_dict.iteritems():
+            for flg,spclist in specs_dict.items():
                 specs_dict[flg] = sorted(spclist)
 
 
@@ -2291,7 +2293,7 @@ class ProcListWriter():
 
 
     def _otf_get_auxilirary_params(self,data):
-        import StringIO
+        import io
         import tokenize
         from kmos import units, rate_aliases
         units_list = []
@@ -2302,10 +2304,10 @@ class ProcListWriter():
             if process.otf_rate:
                 exprs.append(process.otf_rate)
             for expr in exprs:
-                for old, new in rate_aliases.iteritems():
+                for old, new in rate_aliases.items():
                     expr=expr.replace(old, new)
                 try:
-                    tokenize_input = StringIO.StringIO(expr).readline
+                    tokenize_input = io.StringIO(expr).readline
                     tokens = list(tokenize.generate_tokens(tokenize_input))
                 except:
                     raise Exception('Could not tokenize expression: %s' % expr)
@@ -2378,7 +2380,7 @@ class ProcListWriter():
         returning the processed line and a list of the
         nr_<species>_<flag> encountered
         """
-        import StringIO, tokenize
+        import io, tokenize
         from kmos import units, rate_aliases
 
         param_names = [param.name for param in data.parameter_list]
@@ -2393,12 +2395,12 @@ class ProcListWriter():
         expr = expr.replace('otf_rate','gr_{}'.format(procname))
 
         # And all aliases need to be replaced
-        for old, new in rate_aliases.iteritems():
+        for old, new in rate_aliases.items():
             expr = expr.replace(old,new)
 
         # Then time to tokenize:
         try:
-            tokenize_input = StringIO.StringIO(expr).readline
+            tokenize_input = io.StringIO(expr).readline
             tokens = list(tokenize.generate_tokens(tokenize_input))
         except:
             raise Exception('kmos.io: Could not tokenize expression: %s' % expr)
@@ -2616,7 +2618,7 @@ class ProcListWriter():
                 out2.write('use lattice\n')
                 out2.write('use proclist_pars\n')
                 if self.separate_proclist_pars:
-                    for i in xrange(nprocs):
+                    for i in range(nprocs):
                         out2.write('use gr_{0:04d}\n'.format(i+1))
                 ## TODO Finish with use statments
 
@@ -2632,7 +2634,7 @@ class ProcListWriter():
             # We will sort out all processes that are (potentially) influenced
             # (inhibited, activated or changed rate)
             # by the executing process
-            inh_procs = [copy.copy([]) for i in xrange(nprocs)]
+            inh_procs = [copy.copy([]) for i in range(nprocs)]
             enh_procs = copy.deepcopy(inh_procs)
             aff_procs = copy.deepcopy(enh_procs)
             # And look into how each of its actions...
@@ -2669,9 +2671,9 @@ class ProcListWriter():
                 print('  ')
 
             ## Get rid of repetition
-            for ip in xrange(nprocs):
+            for ip in range(nprocs):
                 inh_procs[ip] = [rel_pos for rel_pos in set(inh_procs[ip])]
-            for ip in xrange(nprocs):
+            for ip in range(nprocs):
                 enh_procs[ip] = [rel_pos for rel_pos in set(enh_procs[ip]) if not
                                  (rel_pos in inh_procs[ip])]
                 aff_procs[ip] = [rel_pos for rel_pos in set(aff_procs[ip]) if not
@@ -2794,7 +2796,7 @@ class ProcListWriter():
         # print('ROUTINE GOT CALLED')
         # print(' ')
 
-        for item in filter(lambda x: not x[0], items):
+        for item in [x for x in items if not x[0]]:
             # [1][2] field of the item determine if this search is intended for enabling (=True) or
             # disabling (=False) a process
             if item[1][2]:
@@ -2811,7 +2813,7 @@ class ProcListWriter():
                 out.write('%scall del_proc(%s, %s)\n' % (' ' * indent, item[1][0], rel_site))
 
         # and only keep those that have conditions
-        items = filter(lambda x: x[0], items)
+        items = [x for x in items if x[0]]
         if not items:
             return
 
@@ -2820,7 +2822,7 @@ class ProcListWriter():
         most_common_coord = _most_common([y.coord for y in _flatten([x[0] for x in items])])
 
         # filter out list of uniq answers for this site
-        answers = [y.species for y in filter(lambda x: x.coord == most_common_coord, _flatten([x[0] for x in items]))]
+        answers = [y.species for y in [x for x in _flatten([x[0] for x in items]) if x.coord == most_common_coord]]
         uniq_answers = list(set(answers))
 
         if self.data.meta.debug > 1:
@@ -2849,11 +2851,8 @@ class ProcListWriter():
             # print('for most_common_coord: %s' % most_common_coord)
             # print(' ')
 
-            nested_items = filter(
-                lambda x:
-                (most_common_coord in [y.coord for y in x[0]]
-                and answer == filter(lambda y: y.coord == most_common_coord, x[0])[0].species),
-                items)
+            nested_items = [x for x in items if (most_common_coord in [y.coord for y in x[0]]
+                and answer == filter(lambda y: y.coord == most_common_coord, x[0])[0].species)]
 
             # print('nested items resulted in:')
             # print(nested_items)
@@ -2864,10 +2863,10 @@ class ProcListWriter():
             pruned_items = []
             for nested_item in nested_items:
 
-                conditions = filter(lambda x: most_common_coord != x.coord, nested_item[0])
+                conditions = [x for x in nested_item[0] if most_common_coord != x.coord]
                 pruned_items.append((conditions, nested_item[1]))
 
-            items = filter(lambda x: x not in nested_items, items)
+            items = [x for x in items if x not in nested_items]
             self._write_optimal_iftree_otf(pruned_items, indent + 4, out)
         out.write('%send select\n\n' % (indent * ' ',))
 
@@ -2924,13 +2923,13 @@ class ProcListWriter():
                 parameters = {}
                 for param in data.parameter_list:
                     parameters[param.name] = {'value': param.value}
-            except Exception, e:
+            except Exception as e:
                 raise UserWarning('Parameter ill-defined(%s)\n%s\nProcess: %s'
                                   % (param, e, process.name))
 
             try:
                 evaluate_rate_expression(process.rate_constant, parameters)
-            except Exception, e:
+            except Exception as e:
                 raise UserWarning('Could not evaluate (%s)\n%s\nProcess: %s'
                                   % (process.rate_constant, e, process.name))
         out.write('    }\n\n')
@@ -3079,7 +3078,7 @@ def export_source(project_tree, export_dir=None, code_generator=None, options=No
 
     for filename in exec_files:
         shutil.copy(os.path.join(APP_ABS_PATH, filename), export_dir)
-        os.chmod(os.path.join(export_dir, filename), 0755)
+        os.chmod(os.path.join(export_dir, filename), 0o755)
 
     # SECOND
     # produce those source files that are written on the fly
diff --git a/kmos/run/__init__.py b/kmos/run/__init__.py
index 1a106ef..cd9b0a9 100644
--- a/kmos/run/__init__.py
+++ b/kmos/run/__init__.py
@@ -78,7 +78,7 @@ import sys
 try:
     from kmc_model import base, lattice, proclist
     import kmc_model
-except Exception, e:
+except Exception as e:
     base = lattice = proclist = None
     print("""Error: %s
     Could not find the kmc module. The kmc implements the actual
@@ -104,7 +104,7 @@ except:
 
 try:
     import kmc_settings as settings
-except Exception, e:
+except Exception as e:
     settings = None
     print("""Error %s
     Could import settings file
@@ -211,10 +211,12 @@ class KMC_Model(Process):
         self.reset()
 
         if hasattr(settings, 'setup_model'):
-            import new
-            self.setup_model = new.instancemethod(settings.setup_model,
-                                                  self,
-                                                  KMC_Model)
+            #NB import new
+            #NB self.setup_model = new.instancemethod(settings.setup_model,
+                                                  # self,
+                                                  # KMC_Model)
+            import types
+            self.setup_model = types.MethodType(settings.setup_model, self)
             self.setup_model()
 
     def __enter__(self, *args, **kwargs):
@@ -245,9 +247,9 @@ class KMC_Model(Process):
         # prepare structures for TOF evaluation
         self.tofs = tofs = get_tof_names()
         self.tof_matrix = np.zeros((len(tofs), proclist.nr_of_proc))
-        for process, tof_count in sorted(settings.tof_count.iteritems()):
+        for process, tof_count in sorted(settings.tof_count.items()):
             process_nr = getattr(self.proclist, process.lower())
-            for tof, tof_factor in tof_count.iteritems():
+            for tof, tof_factor in tof_count.items():
                 self.tof_matrix[tofs.index(tof), process_nr - 1] += tof_factor
 
         # prepare procstat
@@ -263,7 +265,7 @@ class KMC_Model(Process):
                 try:
                     self.species_representation[len(self.species_representation)] \
                     = eval(settings.representations[species])
-                except Exception, e:
+                except Exception as e:
                     print('Trouble with representation %s'
                            % settings.representations[species])
                     print(e)
@@ -353,7 +355,7 @@ class KMC_Model(Process):
         Useful for the header line of an ASCII output.
         """
         tofs = []
-        for _, value in settings.tof_count.iteritems():
+        for _, value in settings.tof_count.items():
             for name in value:
                 if name not in tofs:
                     tofs.append(name)
@@ -413,7 +415,7 @@ class KMC_Model(Process):
         if not base.is_allocated():
             self.reset()
         while True:
-            for _ in xrange(self.steps_per_frame):
+            for _ in range(self.steps_per_frame):
                 proclist.do_kmc_step()
             if self.autosend and not self.image_queue.full():
                 atoms = self.get_atoms()
@@ -543,7 +545,7 @@ class KMC_Model(Process):
         import ase.data.colors
         jmol_colors = ase.data.colors.jmol_colors
 
-        for i in xrange(frames):
+        for i in range(frames):
             atoms = self.get_atoms(reset_time_overrun=False)
             filename = '{prefix:s}_{i:06d}.{suffix:s}'.format(**locals())
             #write('%s_%06i.%s' % (prefix, i, suffix),
@@ -644,10 +646,10 @@ class KMC_Model(Process):
             kmos_tags = {}
             ase = import_ase()
             atoms = ase.atoms.Atoms()
-            for i in xrange(lattice.system_size[0]):
-                for j in xrange(lattice.system_size[1]):
-                    for k in xrange(lattice.system_size[2]):
-                        for n in xrange(1, 1 + lattice.spuck):
+            for i in range(lattice.system_size[0]):
+                for j in range(lattice.system_size[1]):
+                    for k in range(lattice.system_size[2]):
+                        for n in range(1, 1 + lattice.spuck):
                             species = lattice.get_species([i, j, k, n])
                             if species == self.null_species:
                                 continue
@@ -680,7 +682,7 @@ class KMC_Model(Process):
                                                       - len(ad_atoms),
                                                       len(atoms)):
                                         kmos_tags[atom] = \
-                                        self.species_tags.values()[species]
+                                        list(self.species_tags.values())[species]
 
                         if self.lattice_representation:
                             lattice_repr = deepcopy(self.lattice_representation)
@@ -819,7 +821,7 @@ class KMC_Model(Process):
         _ = self.get_atoms(geometry = False, reset_time_overrun = False)
 
         # sample over trajectory
-        for sample in xrange(samples):
+        for sample in range(samples):
             self.do_steps(sample_size/samples)
             atoms = self.get_atoms(geometry=False, reset_time_overrun=False)
             delta_ts.append(atoms.delta_t)
@@ -856,7 +858,7 @@ class KMC_Model(Process):
             return ((' '.join(['%.5e'] * len(outdata)) + '\n') % outdata)
         elif output == 'dict':
             header = self.get_std_header()[1:].split()
-            return dict(zip(header, outdata))
+            return dict(list(zip(header, outdata)))
         else:
             raise UserWarning(
                 "Output format {output} not defined. I only know 'str' and 'dict'")
@@ -1269,7 +1271,7 @@ class KMC_Model(Process):
                 if self.base.get_avail_site(process, site, 2):
                     avail.append(ProcInt(process, self.settings))
 
-        except Exception, e:
+        except Exception as e:
             # if is not iterable, interpret as process
             for x in range(self.lattice.system_size[0]):
                 for y in range(self.lattice.system_size[1]):
@@ -1350,7 +1352,8 @@ class KMC_Model(Process):
         """
         if hasattr(self.proclist, 'backend'):
             try:
-                return ''.join(self.proclist.backend)
+                #NB return ''.join(self.proclist.backend)
+                return self.proclist.backend.tostring().decode('utf-8')
             except:
                 return '???'
         else:
@@ -1552,7 +1555,7 @@ class Model_Parameters(object):
     def __repr__(self):
         fixed_parameters = dict((name, param)
                                 for name, param
-                                in settings.parameters.items()
+                                in list(settings.parameters.items())
                                 if not param['adjustable'])
         res = '# kMC model parameters (%i, fixed %i)\n' \
                % (len(settings.parameters), len(fixed_parameters))
@@ -1752,7 +1755,7 @@ class Model_Rate_Constants_OTF(Model_Rate_Constants):
                           ).split()
         if nr_vars:
             input_array = np.zeros([len(nr_vars)],int)
-            for nr_var, value in kwargs.iteritems():
+            for nr_var, value in kwargs.items():
                 if nr_var in nr_vars:
                     input_array[nr_vars.index(nr_var)] = int(value)
 
@@ -1867,7 +1870,7 @@ class _ModelRunner(type):
         obj = super(_ModelRunner, cls).__new__(cls, name, bases, dct)
         obj.runner_name = name
         obj.parameters = OrderedDict()
-        for key, item in dct.items():
+        for key, item in list(dct.items()):
             if key == '__module__':
                 pass
             elif isinstance(item, ModelParameter):
@@ -1875,7 +1878,7 @@ class _ModelRunner(type):
 
         return obj
 
-class ModelRunner(object):
+class ModelRunner(object, metaclass=_ModelRunner):
     """
 Setup and initiate many runs in parallel over a regular grid
 of parameters. A standard type of script is given below.
@@ -1897,15 +1900,13 @@ and <classname>.lock should be moved out of the way ::
 
     """
 
-    __metaclass__ = _ModelRunner
-
     def __product(self, *args, **kwds):
         """Manual implementation of itertools.product for
           python <= 2.5 """
 
         # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
         # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
-        pools = map(tuple, args) * kwds.get('repeat', 1)
+        pools = list(map(tuple, args)) * kwds.get('repeat', 1)
         result = [[]]
         for pool in pools:
             result = [x + [y] for x in result for y in pool]
@@ -1967,7 +1968,7 @@ and <classname>.lock should be moved out of the way ::
             #===========================
             self.__touch(lockfile)
             fdata = file(lockfile)
-            readlines = map(lambda x: x.strip(), fdata.readlines())
+            readlines = [x.strip() for x in fdata.readlines()]
             fdata.close()
             if input_line in readlines:
                 continue
@@ -1983,7 +1984,7 @@ and <classname>.lock should be moved out of the way ::
                               random_seed=random_seed,
                               cache_file='%s_configs/config_%s.pckl'
                                           % (self.runner_name, input_line))
-            for name, value in zip(self.parameters.keys(), datapoint):
+            for name, value in zip(list(self.parameters.keys()), datapoint):
                 setattr(model.parameters, name, value)
 
             #============================
@@ -2092,7 +2093,7 @@ and <classname>.lock should be moved out of the way ::
 
         if variable_parameters is None:
             variable_parameters = {}
-            for param_name, param in self.parameters.items():
+            for param_name, param in list(self.parameters.items()):
                 if param.steps > 1:
                     variable_parameters[param_name] = param
         else:
@@ -2112,7 +2113,7 @@ and <classname>.lock should be moved out of the way ::
         if len(variable_parameters) == 0:
             print("No variable parameter. Nothing to plot.")
         elif len(variable_parameters) == 1:
-            xvar = variable_parameters.keys()[0]
+            xvar = list(variable_parameters.keys())[0]
             data.sort(order=xvar)
             for occ in plot_occs:
                 occs = [data[name] for name in data.dtype.names if name.startswith(occ)]
@@ -2147,8 +2148,8 @@ and <classname>.lock should be moved out of the way ::
         if len(variable_parameters) == 0:
             print("No variable parameter. Nothing to plot.")
         elif len(variable_parameters) == 1:
-            xvar = variable_parameters.keys()[0]
-            param = variable_parameters.values()[0]
+            xvar = list(variable_parameters.keys())[0]
+            param = list(variable_parameters.values())[0]
             data.sort(order=xvar)
             for tof in plot_tofs:
                 tof = tof.replace(')', '').replace('(', '')
@@ -2198,7 +2199,7 @@ and <classname>.lock should be moved out of the way ::
         """
 
         parameters = []
-        for parameter in self.parameters.values():
+        for parameter in list(self.parameters.values()):
             parameters.append(parameter.get_grid())
         points = list(self.__product(*tuple(parameters)))
 
@@ -2249,7 +2250,7 @@ def set_rate_constants(parameters=None, print_rates=None):
             if print_rates:
                 n = int(4 * log(rate_const))
                 print('%30s: %.3e s^{-1}: %s' % (proc, rate_const, '#' * n))
-        except Exception, e:
+        except Exception as e:
             raise UserWarning(
                 "Could not set %s for process %s!\nException: %s" \
                     % (rate_expr, proc, e))
@@ -2259,7 +2260,7 @@ def set_rate_constants(parameters=None, print_rates=None):
     # FIXME
     # update chemical potentials (works for otf backend only)
     if hasattr(proclist,'update_user_parameter'):
-         for name,entry in settings.parameters.iteritems():
+         for name,entry in settings.parameters.items():
              proclist.update_user_parameter(
                  getattr(proclist,name.lower()),
                  evaluate_rate_expression(
@@ -2290,7 +2291,7 @@ def import_ase():
 def get_tof_names():
     """Return names turn-over-frequencies (TOF) previously defined in model."""
     tofs = []
-    for process, tof_count in settings.tof_count.iteritems():
+    for process, tof_count in settings.tof_count.items():
         for tof in tof_count:
             if tof not in tofs:
                 tofs.append(tof)
diff --git a/kmos/run/steady_state.py b/kmos/run/steady_state.py
index e637095..5133849 100644
--- a/kmos/run/steady_state.py
+++ b/kmos/run/steady_state.py
@@ -107,7 +107,7 @@ def make_ewma_plots(data, L, alpha, bias_threshold, seed):
     Most for debugging purposes if the EWMA based steady-state analysis makes was sensible.
     """
     from matplotlib import pyplot as plt
-    for key, y in data.items():
+    for key, y in list(data.items()):
         if not 'time' in key or 'step' in key:
             y = np.array(y)
             plt.clf()
@@ -183,7 +183,7 @@ def sample_steady_state(model, batch_size=1000000,
         data = model.get_std_sampled_data(
             100, batch_size, tof_method=tof_method, output='dict')
 
-        for key, data_point in data.items():
+        for key, data_point in list(data.items()):
             hist.setdefault(key, []).append(data_point)
 
         max_scrap = 0.
@@ -195,7 +195,7 @@ def sample_steady_state(model, batch_size=1000000,
 
         else:
             if batch % check_frequency == 0:
-                for key, y in hist.items():
+                for key, y in list(hist.items()):
                     if 'time' in key or 'step' in key:
                         continue
                     scrap_fraction = get_scrap_fraction(
@@ -222,11 +222,11 @@ def sample_steady_state(model, batch_size=1000000,
                     break
 
     steady_state_start = int(batch * bias_threshold)
-    for key, value in hist.items():
+    for key, value in list(hist.items()):
         hist[key] = np.array(value[steady_state_start:])
 
     data = {}
-    for key, values in hist.items():
+    for key, values in list(hist.items()):
         if 'time' in key:
             data[key] = values[-1]
         elif 'step' in key:
diff --git a/kmos/types.py b/kmos/types.py
index 78a5afa..9ae12af 100644
--- a/kmos/types.py
+++ b/kmos/types.py
@@ -316,8 +316,8 @@ class Project(object):
         """Return representation of model as can be written into a *.ini File.
 
         """
-        from ConfigParser import ConfigParser
-        from StringIO import StringIO
+        from configparser import ConfigParser
+        from io import StringIO
 
         config = ConfigParser()
         config.optionxform = str
@@ -572,7 +572,7 @@ class Project(object):
                               os.path.splitext(filename)[-1])
 
     def export_xml_file(self, filename, validate=True):
-        f = file(filename, 'w')
+        f = open(filename, 'w')
         f.write(str(self))
         f.close()
 
@@ -592,9 +592,9 @@ class Project(object):
         self.filename = filename
 
     def import_ini_file(self, filename):
-        from ConfigParser import ConfigParser
+        from configparser import ConfigParser
         from kmos.utils import evaluate_template
-        from StringIO import StringIO
+        from io import StringIO
 
         config = ConfigParser()
         config.optionxform = str
@@ -1215,8 +1215,7 @@ class Project(object):
         for x in self.get_processes():
             for y in x.condition_list + x.action_list:
                 stripped_speciess = y.species.replace('$', '').replace('^', '')
-                stripped_speciess = map(
-                    lambda x: x.strip(), stripped_speciess.split(' or '))
+                stripped_speciess = [x.strip() for x in stripped_speciess.split(' or ')]
 
                 for stripped_species in stripped_speciess:
                     if not stripped_species in species_names:
@@ -1461,7 +1460,7 @@ class LayerList(FixedObject, list):
         """
 
         def drange(n):
-            return range(1 - n, n)
+            return list(range(1 - n, n))
 
         layers = [layer for layer in self if layer.name == layer_name]
         if layers:
@@ -1469,7 +1468,7 @@ class LayerList(FixedObject, list):
         else:
             raise UserWarning('No Layer named %s found.' % layer_name)
 
-        if site_name is not None and not any(map(lambda x: re.search(site_name, x), ['_'.join(x.name.split('_')) for x in layer.sites])):
+        if site_name is not None and not any([re.search(site_name, x) for x in ['_'.join(x.name.split('_')) for x in layer.sites]]):
             raise UserWarning('Layer {layer_name} has no site matching {site_name}. Please check spelling and try again.'.format(**locals()))
 
         if site_name is None:
@@ -1513,7 +1512,8 @@ class LayerList(FixedObject, list):
 
         offset = np.array(coord.offset)
         cell = self.cell
-        layer = filter(lambda x: x.name == coord.layer, list(self))[0]
+        # layer = filter(lambda x: x.name == coord.layer, list(self))[0]
+        layer = [x for x in list(self) if x.name == coord.layer][0]
         sites = [x for x in layer.sites if x.name == coord.name]
         if not sites:
             raise UserWarning('No site names %s in %s found!' %
@@ -1560,8 +1560,7 @@ class Layer(FixedObject, CorrectlyNamed):
             self.sites.append(site)
 
     def get_site(self, site_name):
-        sites = filter(lambda site: site.name == site_name,
-                       self.sites)
+        sites = [site for site in self.sites if site.name == site_name]
         if not sites:
             raise Exception('Site not found')
         return sites[0]
@@ -1726,12 +1725,6 @@ class Coord(FixedObject):
     def __hash__(self):
         return hash(self.__repr__())
 
-    def __cmp__(self, other):
-        return cmp(
-            (self.layer, tuple(self.offset), self.name),
-            (other.layer, tuple(other.offset), other.name)
-        )
-
     def __sub__(a, b):
         """When subtracting two lattice coordinates from each other,
         i.e. a-b, we want to keep the name and layer from a, and just
@@ -1802,12 +1795,13 @@ class Coord(FixedObject):
 
 
 def cmp_coords(self, other):
+    #NB maybe there's a cleaner/faster way of replicating old cmp behavior
     if self.layer != other.layer:
-        return cmp(self.layer, other.layer)
+        return (-1 if self.layer < other.layer else 1)
     elif (self.offset != other.offset).any():
         for i in range(3):
             if self.offset[i] != other.offset[i]:
-                return cmp(self.offset[i], other.offset[i])
+                return (-1 if self.offset[i] < other.offset[i] else 1)
     else:
         return 0
 
@@ -2164,7 +2158,7 @@ def parse_chemical_expression(eq, process, project_tree):
 
     # split at ->
     if eq.count('->') != 1:
-        raise StandardError('Chemical expression must contain ' +
+        raise Exception('Chemical expression must contain ' +
                             'exactly one "->"\n%s' % eq)
     eq = re.split('->', eq)
     left, right = eq
@@ -2182,7 +2176,7 @@ def parse_chemical_expression(eq, process, project_tree):
     # small validity checking
     for term in left + right:
         if term.count('@') != 1:
-            raise StandardError('Each term needs to contain ' +
+            raise Exception('Each term needs to contain ' +
                                 'exactly one @:\n%s' % term)
 
     # split each term again at @
@@ -2194,11 +2188,9 @@ def parse_chemical_expression(eq, process, project_tree):
     # check if species is defined
     for term in left + right:
         if term[0][0] in ['$', '^'] and term[0][1:]:
-            if not filter(lambda x: x.name == term[0][1:],
-                          project_tree.get_speciess()):
+            if not [x for x in project_tree.get_speciess() if x.name == term[0][1:]]:
                 raise UserWarning('Species %s unknown ' % term[0:])
-        elif not filter(lambda x: x.name == term[0],
-                        project_tree.get_speciess()):
+        elif not [x for x in project_tree.get_speciess() if x.name == term[0]]:
             raise UserWarning('Species %s unknown ' % term[0])
 
     condition_list = []
@@ -2212,8 +2204,7 @@ def parse_chemical_expression(eq, process, project_tree):
 
         if len(coord_term) == 2:
             name = coord_term[0]
-            active_layers = filter(lambda x: x.active,
-                                   project_tree.get_layers())
+            active_layers = [x for x in project_tree.get_layers() if x.active]
             if len(active_layers) == 1:
                 layer = active_layers[0].name
             else:  # if more than one active try to guess layer from name
@@ -2266,7 +2257,7 @@ def parse_chemical_expression(eq, process, project_tree):
     # every condition that does not have a corresponding action on the
     # same coordinate gets complemented with a 'default_species' action
     for condition in condition_list:
-        if not filter(lambda x: x.coord == condition.coord, action_list):
+        if not [x for x in action_list if x.coord == condition.coord]:
             action_list.append(ConditionAction(species=default_species,
                                                coord=condition.coord))
 
@@ -2274,7 +2265,7 @@ def parse_chemical_expression(eq, process, project_tree):
     # the same coordinate gets complemented with a 'default_species'
     # condition
     for action in action_list:
-        if not filter(lambda x: x.coord == action.coord, condition_list) \
+        if not [x for x in condition_list if x.coord == action.coord] \
                 and not action.species[0] in ['^', '$']:
             condition_list.append(ConditionAction(species=default_species,
                                                   coord=action.coord))
@@ -2289,9 +2280,7 @@ def parse_chemical_expression(eq, process, project_tree):
         #      the left side, the condition will be added with the same
         #      species as the annihilated one.
         if action.species[0] == '$':
-            corresponding_condition = filter(lambda x:
-                                             x.coord == action.coord,
-                                             condition_list)
+            corresponding_condition = [x for x in condition_list if x.coord == action.coord]
             if action.species[1:]:
                 if not corresponding_condition:
                     condition_list.append(
diff --git a/kmos/utils/__init__.py b/kmos/utils/__init__.py
index 3fd04d9..5298907 100644
--- a/kmos/utils/__init__.py
+++ b/kmos/utils/__init__.py
@@ -18,10 +18,10 @@
 #    You should have received a copy of the GNU General Public License
 #    along with kmos.  If not, see <http://www.gnu.org/licenses/>.
 
-from __future__ import with_statement
+
 import re
 from time import time
-from StringIO import StringIO
+from io import StringIO
 from kmos.utils.ordered_dict import OrderedDict
 
 ValidationError = UserWarning
@@ -135,7 +135,7 @@ def write_py(fileobj, images, **kwargs):
 
 def get_ase_constructor(atoms):
     """Return the ASE constructor string for `atoms`."""
-    if isinstance(atoms, basestring):
+    if isinstance(atoms, str):
         #return atoms
         atoms = eval(atoms)
     if type(atoms) is list:
@@ -191,13 +191,13 @@ def download(project):
     response = HttpResponse(mimetype='application/x-zip-compressed')
     response['Content-Disposition'] = 'attachment; filename="kmos_export.zip"'
 
-    if isinstance(project, basestring):
+    if isinstance(project, str):
         project = import_xml(project)
 
     try:
-        from cStringIO import StringIO
+        from io import StringIO
     except:
-        from StringIO import StringIO
+        from io import StringIO
     stringio = StringIO()
     zfile = zipfile.ZipFile(stringio, 'w')
 
@@ -322,8 +322,8 @@ def evaluate_kind_values(infile, outfile):
         args, kwargs = parse_args(args)
         return import_selected_kind().real_kind(*args, **kwargs)
 
-    infile = file(infile)
-    outfile = file(outfile, 'w')
+    infile = open(infile)
+    outfile = open(outfile, 'w')
     int_pattern = re.compile((r'(?P<before>.*)selected_int_kind'
                               '\((?P<args>.*)\)(?P<after>.*)'),
                              flags=re.IGNORECASE)
@@ -426,7 +426,12 @@ def build(options):
 
     if options.debug:
         extra_flags += ' -DDEBUG'
-    call.append('--f90flags="%s"' % extra_flags)
+    #NB presence of " around f90flags argument confuses f2py.  
+    #NB Command line argument separation already set by 
+    #NB split into separate str items in list. Not
+    #NB sure why it ever worked.
+    #NB call.append('--f90flags="%s"' % extra_flags)
+    call.append('--f90flags=%s' % extra_flags)
     call.append('-m')
     call.append(module_name)
     call += src_files
@@ -567,7 +572,13 @@ def evaluate_template(template, escape_python=False, **kwargs):
         # just return the original
         if not matched:
             return template
-        exec(python_lines)
+        #NB python3 exec doesn't modify local variables.
+        #NB create local dict and copy back "result" explicitly
+        #NB if any other local variables are modified, that change
+        #NB will be lost.
+        ldict = locals().copy()
+        exec(python_lines, globals(), ldict)
+        result = ldict['result']
 
         # second turn literary lines into write statements
         python_lines = ''
@@ -584,7 +595,10 @@ def evaluate_template(template, escape_python=False, **kwargs):
                 python_lines += '%sresult += ("""%s""".format(**dict(locals())))\n' \
                     % (' ' * (len(line.expandtabs(4)) - len(line.lstrip())),  line.lstrip())
 
-        exec(python_lines)
+        #NB see note above
+        ldict = locals().copy()
+        exec(python_lines, globals(), ldict)
+        result = ldict['result'] 
 
     else:
         # first just replace verbose lines by pass to check syntax
@@ -601,7 +615,10 @@ def evaluate_template(template, escape_python=False, **kwargs):
                 python_lines += line
         if not matched:
             return template
-        exec(python_lines)
+        #NB see note above
+        ldict = locals().copy()
+        exec(python_lines, globals(), ldict)
+        result = ldict['result']
 
         # second turn literary lines into write statements
         python_lines = ''
@@ -616,6 +633,9 @@ def evaluate_template(template, escape_python=False, **kwargs):
             else:
                 python_lines += line
 
-        exec(python_lines)
+        #NB see note above
+        ldict = locals().copy()
+        exec(python_lines, globals(), ldict) 
+        result = ldict['result']
 
     return result
diff --git a/kmos/utils/ordered_dict.py b/kmos/utils/ordered_dict.py
index 7ea0c33..3077963 100644
--- a/kmos/utils/ordered_dict.py
+++ b/kmos/utils/ordered_dict.py
@@ -3,9 +3,9 @@
 # Passes Python2.7's test suite and incorporates all the latest updates.
 
 try:
-    from thread import get_ident as _get_ident
+    from _thread import get_ident as _get_ident
 except ImportError:
-    from dummy_thread import get_ident as _get_ident
+    from _dummy_thread import get_ident as _get_ident
 
 try:
     from _abcoll import KeysView, ValuesView, ItemsView
@@ -79,7 +79,7 @@ class OrderedDict(dict):
     def clear(self):
         'od.clear() -> None.  Remove all items from od.'
         try:
-            for node in self.__map.itervalues():
+            for node in self.__map.values():
                 del node[:]
             root = self.__root
             root[:] = [root, root, None]
@@ -162,12 +162,12 @@ class OrderedDict(dict):
             for key in other:
                 self[key] = other[key]
         elif hasattr(other, 'keys'):
-            for key in other.keys():
+            for key in list(other.keys()):
                 self[key] = other[key]
         else:
             for key, value in other:
                 self[key] = value
-        for key, value in kwds.items():
+        for key, value in list(kwds.items()):
             self[key] = value
 
     __update = update  # let subclasses override update without breaking __init__
@@ -203,7 +203,7 @@ class OrderedDict(dict):
         try:
             if not self:
                 return '%s()' % (self.__class__.__name__,)
-            return '%s(%r)' % (self.__class__.__name__, self.items())
+            return '%s(%r)' % (self.__class__.__name__, list(self.items()))
         finally:
             del _repr_running[call_key]
 
@@ -238,7 +238,7 @@ class OrderedDict(dict):
 
         '''
         if isinstance(other, OrderedDict):
-            return len(self)==len(other) and self.items() == other.items()
+            return len(self)==len(other) and list(self.items()) == list(other.items())
         return dict.__eq__(self, other)
 
     def __ne__(self, other):
diff --git a/kmos/utils/progressbar.py b/kmos/utils/progressbar.py
index 97cb058..4f87e2f 100644
--- a/kmos/utils/progressbar.py
+++ b/kmos/utils/progressbar.py
@@ -7,7 +7,7 @@ Usage:
     p.render(percentage, message)
 """
 
-import terminal
+from . import terminal
 import sys
 
 class ProgressBar(object):
@@ -64,9 +64,9 @@ class ProgressBar(object):
         data = self.TEMPLATE % {
             'percent': percent,
             'color': self.color,
-            'progress': self.block * self.progress,
+            'progress': self.block * int(self.progress),
             'normal': terminal.NORMAL,
-            'empty': self.empty * (bar_width - self.progress),
+            'empty': self.empty * int(bar_width - self.progress),
             'message': message
         }
         sys.stdout.write(data)
@@ -77,5 +77,5 @@ class ProgressBar(object):
     def clear(self):
         """Clear all printed lines"""
         sys.stdout.write(
-            self.lines * (terminal.UP + terminal.BOL + terminal.CLEAR_EOL)
+            str(self.lines * (terminal.UP + terminal.BOL + terminal.CLEAR_EOL))
         )
diff --git a/kmos/utils/terminal.py b/kmos/utils/terminal.py
index 4724069..e4f1b76 100644
--- a/kmos/utils/terminal.py
+++ b/kmos/utils/terminal.py
@@ -75,7 +75,7 @@ def render(text):
 try:
     import curses
     setup()
-except Exception, e:
+except Exception as e:
     # There is a failure; set all attributes to default
-    print 'Warning: %s' % e
+    print('Warning: %s' % e)
     default()
diff --git a/kmos/view.py b/kmos/view.py
index 6ef814f..dc4878d 100644
--- a/kmos/view.py
+++ b/kmos/view.py
@@ -33,7 +33,7 @@ try:
     import gobject
     from ase.gui.view import View
     from ase.gui.status import Status
-except Exception, e:
+except Exception as e:
     View = type('View', (), {})
     Status = type('Status', (), {})
     print('Warning: GTK not available. Cannot run graphical front-end')
@@ -48,7 +48,7 @@ try:
     else:
         matplotlib.use('GTKAgg')
     import matplotlib.pylab as plt
-except Exception, e:
+except Exception as e:
     print('Could not import matplotlib frontend for real-time plotting')
     print(e)
 
@@ -312,7 +312,7 @@ class KMC_ViewBox(threading.Thread, View, Status, FakeUI):
                 self.signal_queue.put('START')
                 self.paused = False
         elif event.string in ['?']:
-            for key, command in signal_dict.items():
+            for key, command in list(signal_dict.items()):
                 print('%4s %s' % (key, command))
         elif event.string in signal_dict:
             self.signal_queue.put(signal_dict.get(event.string, ''))
@@ -331,7 +331,7 @@ class KMC_ViewBox(threading.Thread, View, Status, FakeUI):
         self.scale *= x
         try:
             atoms = self.image_queue.get()
-        except Exception, e:
+        except Exception as e:
             atoms = ase.atoms.Atoms()
             print(e)
         self.update_vbox(atoms)
diff --git a/setup.py b/setup.py
index fd13bbb..9808aa1 100755
--- a/setup.py
+++ b/setup.py
@@ -39,7 +39,7 @@ requires = [
                     'pygtk',
                    ]
 license = 'COPYING'
-long_description = file('README.rst').read()
+long_description = open('README.rst').read()
 name='python-kmos'
 packages = [
            'kmos',
diff --git a/tests/complex_render_test/test_render_Pdsqrt5_process_list.py b/tests/complex_render_test/test_render_Pdsqrt5_process_list.py
index 4380dcf..63294b0 100644
--- a/tests/complex_render_test/test_render_Pdsqrt5_process_list.py
+++ b/tests/complex_render_test/test_render_Pdsqrt5_process_list.py
@@ -135,7 +135,7 @@ class ModelBuilder(object):
                                     4. + z),
                             'tags': "hollow oxygen"}
 
-        for name, data in sites.iteritems():
+        for name, data in sites.items():
             tags = data['tags']
             site = Site(name=name,
                         default_species='empty',
diff --git a/tests/export_test/test_build_run.py b/tests/export_test/test_build_run.py
index b0a86a3..91a5801 100644
--- a/tests/export_test/test_build_run.py
+++ b/tests/export_test/test_build_run.py
@@ -261,12 +261,12 @@ def run(i=0, edir=''):
     assert not model.deallocate()
 
 def run_in_serial(edir):
-    for i in xrange(20):
+    for i in range(20):
         run(i, edir)
 
 def run_in_parallel(edir):
     from multiprocessing import Process
-    for i in xrange(8):
+    for i in range(8):
         process = Process(target=run, args=(10, edir))
         process.start()
 
